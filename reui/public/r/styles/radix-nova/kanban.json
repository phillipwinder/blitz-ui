{"$schema":"https://ui.shadcn.com/schema/registry-item.json","name":"kanban","type":"registry:ui","title":"Kanban","description":"","dependencies":["@dnd-kit/core","@dnd-kit/sortable","@dnd-kit/utilities","radix-ui"],"registryDependencies":[],"files":[{"path":"kanban.tsx","type":"registry:ui","content":"/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\"\n\nimport * as React from \"react\"\nimport {\n  createContext,\n  CSSProperties,\n  HTMLAttributes,\n  ReactNode,\n  useCallback,\n  useContext,\n  useLayoutEffect,\n  useMemo,\n  useState,\n} from \"react\"\nimport {\n  defaultDropAnimationSideEffects,\n  DndContext,\n  DragEndEvent,\n  DragOverEvent,\n  DragOverlay,\n  DragStartEvent,\n  DropAnimation,\n  KeyboardSensor,\n  MeasuringStrategy,\n  Modifiers,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n  type DraggableAttributes,\n  type DraggableSyntheticListeners,\n} from \"@dnd-kit/core\"\nimport {\n  arrayMove,\n  defaultAnimateLayoutChanges,\n  rectSortingStrategy,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n  type AnimateLayoutChanges,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport { Slot } from \"radix-ui\"\nimport { createPortal } from \"react-dom\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface KanbanContextProps<T> {\n  columns: Record<string, T[]>\n  setColumns: (columns: Record<string, T[]>) => void\n  getItemId: (item: T) => string\n  columnIds: string[]\n  activeId: UniqueIdentifier | null\n  setActiveId: (id: UniqueIdentifier | null) => void\n  findContainer: (id: UniqueIdentifier) => string | undefined\n  isColumn: (id: UniqueIdentifier) => boolean\n  modifiers?: Modifiers\n}\n\nconst KanbanContext = createContext<KanbanContextProps<any>>({\n  columns: {},\n  setColumns: () => {},\n  getItemId: () => \"\",\n  columnIds: [],\n  activeId: null,\n  setActiveId: () => {},\n  findContainer: () => undefined,\n  isColumn: () => false,\n  modifiers: undefined,\n})\n\nconst ColumnContext = createContext<{\n  attributes: DraggableAttributes\n  listeners: DraggableSyntheticListeners | undefined\n  isDragging?: boolean\n  disabled?: boolean\n}>({\n  attributes: {} as DraggableAttributes,\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n})\n\nconst ItemContext = createContext<{\n  listeners: DraggableSyntheticListeners | undefined\n  isDragging?: boolean\n  disabled?: boolean\n}>({\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n})\n\nconst IsOverlayContext = createContext(false)\n\nconst animateLayoutChanges: AnimateLayoutChanges = (args) =>\n  defaultAnimateLayoutChanges({ ...args, wasDragging: true })\n\nconst dropAnimationConfig: DropAnimation = {\n  sideEffects: defaultDropAnimationSideEffects({\n    styles: {\n      active: {\n        opacity: \"0.4\",\n      },\n    },\n  }),\n}\n\nexport interface KanbanMoveEvent {\n  event: DragEndEvent\n  activeContainer: string\n  activeIndex: number\n  overContainer: string\n  overIndex: number\n}\n\nexport interface KanbanRootProps<T> extends HTMLAttributes<HTMLDivElement> {\n  value: Record<string, T[]>\n  onValueChange: (value: Record<string, T[]>) => void\n  getItemValue: (item: T) => string\n  children: ReactNode\n  onMove?: (event: KanbanMoveEvent) => void\n  asChild?: boolean\n  modifiers?: Modifiers\n}\n\nfunction Kanban<T>({\n  value,\n  onValueChange,\n  getItemValue,\n  children,\n  className,\n  asChild = false,\n  onMove,\n  modifiers,\n  ...props\n}: KanbanRootProps<T>) {\n  const columns = value\n  const setColumns = onValueChange\n  const [activeId, setActiveId] = useState<UniqueIdentifier | null>(null)\n\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 10,\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  )\n\n  const columnIds = useMemo(() => Object.keys(columns), [columns])\n\n  const isColumn = useCallback(\n    (id: UniqueIdentifier) => columnIds.includes(id as string),\n    [columnIds]\n  )\n\n  const findContainer = useCallback(\n    (id: UniqueIdentifier) => {\n      if (isColumn(id)) return id as string\n      return columnIds.find((key) =>\n        columns[key].some((item) => getItemValue(item) === id)\n      )\n    },\n    [columns, columnIds, getItemValue, isColumn]\n  )\n\n  const handleDragStart = useCallback((event: DragStartEvent) => {\n    setActiveId(event.active.id)\n  }, [])\n\n  const handleDragOver = useCallback(\n    (event: DragOverEvent) => {\n      if (onMove) {\n        return\n      }\n\n      const { active, over } = event\n      if (!over) return\n\n      if (isColumn(active.id)) return\n\n      const activeContainer = findContainer(active.id)\n      const overContainer = findContainer(over.id)\n\n      if (!activeContainer || !overContainer) {\n        return\n      }\n\n      if (activeContainer !== overContainer) {\n        const activeItems = columns[activeContainer]\n        const overItems = columns[overContainer]\n\n        const activeIndex = activeItems.findIndex(\n          (item: T) => getItemValue(item) === active.id\n        )\n        let overIndex = overItems.findIndex(\n          (item: T) => getItemValue(item) === over.id\n        )\n\n        // If dropping on the column itself, not an item\n        if (isColumn(over.id)) {\n          overIndex = overItems.length\n        }\n\n        const newActiveItems = [...activeItems]\n        const newOverItems = [...overItems]\n        const [movedItem] = newActiveItems.splice(activeIndex, 1)\n        newOverItems.splice(overIndex, 0, movedItem)\n\n        setColumns({\n          ...columns,\n          [activeContainer]: newActiveItems,\n          [overContainer]: newOverItems,\n        })\n      } else {\n        const container = activeContainer\n        const activeIndex = columns[container].findIndex(\n          (item: T) => getItemValue(item) === active.id\n        )\n        const overIndex = columns[container].findIndex(\n          (item: T) => getItemValue(item) === over.id\n        )\n\n        if (activeIndex !== overIndex) {\n          setColumns({\n            ...columns,\n            [container]: arrayMove(columns[container], activeIndex, overIndex),\n          })\n        }\n      }\n    },\n    [findContainer, getItemValue, isColumn, setColumns, columns, onMove]\n  )\n\n  const handleDragCancel = useCallback(() => {\n    setActiveId(null)\n  }, [])\n\n  const handleDragEnd = useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event\n      setActiveId(null)\n\n      if (!over) return\n\n      // Handle item move callback\n      if (onMove && !isColumn(active.id)) {\n        const activeContainer = findContainer(active.id)\n        const overContainer = findContainer(over.id)\n\n        if (activeContainer && overContainer) {\n          const activeIndex = columns[activeContainer].findIndex(\n            (item: T) => getItemValue(item) === active.id\n          )\n          const overIndex = isColumn(over.id)\n            ? columns[overContainer].length\n            : columns[overContainer].findIndex(\n                (item: T) => getItemValue(item) === over.id\n              )\n\n          onMove({\n            event,\n            activeContainer,\n            activeIndex,\n            overContainer,\n            overIndex,\n          })\n        }\n        return\n      }\n\n      // Handle column reordering\n      if (isColumn(active.id) && isColumn(over.id)) {\n        const activeIndex = columnIds.indexOf(active.id as string)\n        const overIndex = columnIds.indexOf(over.id as string)\n        if (activeIndex !== overIndex) {\n          const newOrder = arrayMove(\n            Object.keys(columns),\n            activeIndex,\n            overIndex\n          )\n          const newColumns: Record<string, T[]> = {}\n          newOrder.forEach((key) => {\n            newColumns[key] = columns[key]\n          })\n          setColumns(newColumns)\n        }\n        return\n      }\n\n      const activeContainer = findContainer(active.id)\n      const overContainer = findContainer(over.id)\n\n      // Handle item reordering within the same column\n      if (\n        activeContainer &&\n        overContainer &&\n        activeContainer === overContainer\n      ) {\n        const container = activeContainer\n        const activeIndex = columns[container].findIndex(\n          (item: T) => getItemValue(item) === active.id\n        )\n        const overIndex = columns[container].findIndex(\n          (item: T) => getItemValue(item) === over.id\n        )\n\n        if (activeIndex !== overIndex) {\n          setColumns({\n            ...columns,\n            [container]: arrayMove(columns[container], activeIndex, overIndex),\n          })\n        }\n      }\n    },\n    [\n      columnIds,\n      columns,\n      findContainer,\n      getItemValue,\n      isColumn,\n      setColumns,\n      onMove,\n    ]\n  )\n\n  const contextValue = useMemo(\n    () => ({\n      columns,\n      setColumns,\n      getItemId: getItemValue,\n      columnIds,\n      activeId,\n      setActiveId,\n      findContainer,\n      isColumn,\n      modifiers,\n    }),\n    [\n      columns,\n      setColumns,\n      getItemValue,\n      columnIds,\n      activeId,\n      findContainer,\n      isColumn,\n      modifiers,\n    ]\n  )\n\n  const Comp = asChild ? Slot.Root : \"div\"\n\n  return (\n    <KanbanContext.Provider value={contextValue}>\n      <DndContext\n        sensors={sensors}\n        modifiers={modifiers}\n        measuring={{\n          droppable: {\n            strategy: MeasuringStrategy.Always,\n          },\n        }}\n        onDragStart={handleDragStart}\n        onDragOver={handleDragOver}\n        onDragEnd={handleDragEnd}\n        onDragCancel={handleDragCancel}\n      >\n        <Comp\n          data-slot=\"kanban\"\n          data-dragging={activeId !== null}\n          className={cn(activeId !== null && \"cursor-grabbing!\", className)}\n          {...props}\n        >\n          {children}\n        </Comp>\n      </DndContext>\n    </KanbanContext.Provider>\n  )\n}\n\nexport interface KanbanBoardProps extends HTMLAttributes<HTMLDivElement> {\n  asChild?: boolean\n}\n\nfunction KanbanBoard({\n  className,\n  asChild = false,\n  children,\n  ...props\n}: KanbanBoardProps) {\n  const { columnIds } = useContext(KanbanContext)\n  const Comp = asChild ? Slot.Root : \"div\"\n\n  return (\n    <SortableContext items={columnIds} strategy={rectSortingStrategy}>\n      <Comp\n        data-slot=\"kanban-board\"\n        className={cn(\"grid auto-rows-fr gap-4 sm:grid-cols-3\", className)}\n        {...props}\n      >\n        {children}\n      </Comp>\n    </SortableContext>\n  )\n}\n\nexport interface KanbanColumnProps extends HTMLAttributes<HTMLDivElement> {\n  value: string\n  disabled?: boolean\n  asChild?: boolean\n}\n\nfunction KanbanColumn({\n  value,\n  className,\n  asChild = false,\n  disabled,\n  children,\n  ...props\n}: KanbanColumnProps) {\n  const isOverlay = useContext(IsOverlayContext)\n\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n    animateLayoutChanges,\n  })\n\n  const { activeId, isColumn } = useContext(KanbanContext)\n  const isColumnDragging = activeId ? isColumn(activeId) : false\n\n  const style = {\n    transition,\n    transform: CSS.Transform.toString(transform),\n  } as CSSProperties\n\n  const Comp = asChild ? Slot.Root : \"div\"\n\n  if (isOverlay) {\n    return (\n      <ColumnContext.Provider\n        value={{\n          attributes: {} as DraggableAttributes,\n          listeners: undefined,\n          isDragging: true,\n          disabled: false,\n        }}\n      >\n        <Comp\n          data-slot=\"kanban-column\"\n          data-value={value}\n          data-dragging={true}\n          className={cn(\"group/kanban-column flex flex-col\", className)}\n          {...props}\n        >\n          {children}\n        </Comp>\n      </ColumnContext.Provider>\n    )\n  }\n\n  return (\n    <ColumnContext.Provider\n      value={{ attributes, listeners, isDragging: isColumnDragging, disabled }}\n    >\n      <Comp\n        data-slot=\"kanban-column\"\n        data-value={value}\n        data-dragging={isSortableDragging}\n        data-disabled={disabled}\n        ref={setNodeRef}\n        style={style}\n        className={cn(\n          \"group/kanban-column flex flex-col\",\n          isSortableDragging && \"z-50 opacity-50\",\n          disabled && \"opacity-50\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </Comp>\n    </ColumnContext.Provider>\n  )\n}\n\nexport interface KanbanColumnHandleProps extends HTMLAttributes<HTMLDivElement> {\n  cursor?: boolean\n  asChild?: boolean\n}\n\nfunction KanbanColumnHandle({\n  className,\n  asChild = false,\n  cursor = true,\n  children,\n  ...props\n}: KanbanColumnHandleProps) {\n  const { attributes, listeners, isDragging, disabled } =\n    useContext(ColumnContext)\n\n  const Comp = asChild ? Slot.Root : \"div\"\n\n  return (\n    <Comp\n      data-slot=\"kanban-column-handle\"\n      data-dragging={isDragging}\n      data-disabled={disabled}\n      {...attributes}\n      {...listeners}\n      className={cn(\n        \"opacity-0 transition-opacity group-hover/kanban-column:opacity-100\",\n        cursor && (isDragging ? \"cursor-grabbing!\" : \"cursor-grab!\"),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </Comp>\n  )\n}\n\nexport interface KanbanItemProps extends HTMLAttributes<HTMLDivElement> {\n  value: string\n  disabled?: boolean\n  asChild?: boolean\n}\n\nfunction KanbanItem({\n  value,\n  className,\n  asChild = false,\n  disabled,\n  children,\n  ...props\n}: KanbanItemProps) {\n  const isOverlay = useContext(IsOverlayContext)\n\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n    animateLayoutChanges,\n  })\n\n  const { activeId, isColumn } = useContext(KanbanContext)\n  const isItemDragging = activeId ? !isColumn(activeId) : false\n\n  const style = {\n    transition,\n    transform: CSS.Transform.toString(transform),\n  } as CSSProperties\n\n  const Comp = asChild ? Slot.Root : \"div\"\n\n  if (isOverlay) {\n    return (\n      <ItemContext.Provider\n        value={{ listeners: undefined, isDragging: true, disabled: false }}\n      >\n        <Comp\n          data-slot=\"kanban-item\"\n          data-value={value}\n          data-dragging={true}\n          className={cn(className)}\n          {...props}\n        >\n          {children}\n        </Comp>\n      </ItemContext.Provider>\n    )\n  }\n\n  return (\n    <ItemContext.Provider\n      value={{ listeners, isDragging: isItemDragging, disabled }}\n    >\n      <Comp\n        data-slot=\"kanban-item\"\n        data-value={value}\n        data-dragging={isSortableDragging}\n        data-disabled={disabled}\n        ref={setNodeRef}\n        style={style}\n        {...attributes}\n        className={cn(\n          isSortableDragging && \"z-50 opacity-50\",\n          disabled && \"opacity-50\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </Comp>\n    </ItemContext.Provider>\n  )\n}\n\nexport interface KanbanItemHandleProps extends HTMLAttributes<HTMLDivElement> {\n  cursor?: boolean\n  asChild?: boolean\n}\n\nfunction KanbanItemHandle({\n  className,\n  asChild = false,\n  cursor = true,\n  children,\n  ...props\n}: KanbanItemHandleProps) {\n  const { listeners, isDragging, disabled } = useContext(ItemContext)\n\n  const Comp = asChild ? Slot.Root : \"div\"\n\n  return (\n    <Comp\n      data-slot=\"kanban-item-handle\"\n      data-dragging={isDragging}\n      data-disabled={disabled}\n      {...listeners}\n      className={cn(\n        cursor && (isDragging ? \"cursor-grabbing!\" : \"cursor-grab!\"),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </Comp>\n  )\n}\n\nexport interface KanbanColumnContentProps extends HTMLAttributes<HTMLDivElement> {\n  value: string\n  asChild?: boolean\n}\n\nfunction KanbanColumnContent({\n  value,\n  className,\n  asChild = false,\n  children,\n  ...props\n}: KanbanColumnContentProps) {\n  const { columns, getItemId } = useContext(KanbanContext)\n\n  const itemIds = useMemo(\n    () => columns[value].map(getItemId),\n    [columns, getItemId, value]\n  )\n\n  const Comp = asChild ? Slot.Root : \"div\"\n\n  return (\n    <SortableContext items={itemIds} strategy={verticalListSortingStrategy}>\n      <Comp\n        data-slot=\"kanban-column-content\"\n        className={cn(\"flex flex-col gap-2\", className)}\n        {...props}\n      >\n        {children}\n      </Comp>\n    </SortableContext>\n  )\n}\n\nexport interface KanbanOverlayProps extends Omit<\n  React.ComponentProps<typeof DragOverlay>,\n  \"children\"\n> {\n  children?:\n    | ReactNode\n    | ((params: {\n        value: UniqueIdentifier\n        variant: \"column\" | \"item\"\n      }) => ReactNode)\n}\n\nfunction KanbanOverlay({ children, className, ...props }: KanbanOverlayProps) {\n  const { activeId, isColumn, modifiers } = useContext(KanbanContext)\n  const [mounted, setMounted] = useState(false)\n\n  useLayoutEffect(() => setMounted(true), [])\n\n  const variant = activeId ? (isColumn(activeId) ? \"column\" : \"item\") : \"item\"\n\n  const content =\n    activeId && children\n      ? typeof children === \"function\"\n        ? children({ value: activeId, variant })\n        : children\n      : null\n\n  if (!mounted) return null\n\n  return createPortal(\n    <DragOverlay\n      dropAnimation={dropAnimationConfig}\n      modifiers={modifiers}\n      className={cn(\"z-50\", activeId && \"cursor-grabbing\", className)}\n      {...props}\n    >\n      <IsOverlayContext.Provider value={true}>\n        {content}\n      </IsOverlayContext.Provider>\n    </DragOverlay>,\n    document.body\n  )\n}\n\nexport {\n  Kanban,\n  KanbanBoard,\n  KanbanColumn,\n  KanbanColumnHandle,\n  KanbanItem,\n  KanbanItemHandle,\n  KanbanColumnContent,\n  KanbanOverlay,\n}","target":"components/reui/kanban.tsx"}]}