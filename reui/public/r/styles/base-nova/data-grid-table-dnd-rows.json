{"$schema":"https://ui.shadcn.com/schema/registry-item.json","name":"data-grid-table-dnd-rows","type":"registry:ui","title":"Data Grid Table Dnd Rows","description":"","dependencies":["@dnd-kit/core","@dnd-kit/modifiers","@dnd-kit/sortable","@dnd-kit/utilities","@tanstack/react-table"],"registryDependencies":["button"],"files":[{"path":"data-grid-table-dnd-rows.tsx","type":"registry:ui","content":"\"use client\"\n\nimport {\n  createContext,\n  CSSProperties,\n  useContext,\n  useId,\n  useMemo,\n  useRef,\n} from \"react\"\nimport { useDataGrid } from \"@/components/reui/data-grid/data-grid\"\nimport {\n  DataGridTableBase,\n  DataGridTableBody,\n  DataGridTableBodyRow,\n  DataGridTableBodyRowCell,\n  DataGridTableBodyRowSkeleton,\n  DataGridTableBodyRowSkeletonCell,\n  DataGridTableEmpty,\n  DataGridTableHead,\n  DataGridTableHeadRow,\n  DataGridTableHeadRowCell,\n  DataGridTableHeadRowCellResize,\n  DataGridTableRowSpacer,\n} from \"@/components/reui/data-grid/data-grid-table\"\nimport {\n  closestCenter,\n  DndContext,\n  KeyboardSensor,\n  MouseSensor,\n  TouchSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n  type DragEndEvent,\n  type Modifier,\n} from \"@dnd-kit/core\"\nimport { restrictToVerticalAxis } from \"@dnd-kit/modifiers\"\nimport {\n  SortableContext,\n  useSortable,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport { Cell, flexRender, HeaderGroup, Row } from \"@tanstack/react-table\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { IconPlaceholder } from \"@/app/(create)/components/icon-placeholder\"\n\n// Context to share sortable listeners from row to handle\ntype SortableContextValue = ReturnType<typeof useSortable>\nconst SortableRowContext = createContext<Pick<\n  SortableContextValue,\n  \"attributes\" | \"listeners\"\n> | null>(null)\n\nfunction DataGridTableDndRowHandle({ className }: { className?: string }) {\n  const context = useContext(SortableRowContext)\n\n  if (!context) {\n    // Fallback if context is not available (shouldn't happen in normal usage)\n    return (\n      <Button\n        variant=\"ghost\"\n        size=\"icon-sm\"\n        className={cn(\n          \"size-7 cursor-move opacity-70 hover:bg-transparent hover:opacity-100\",\n          className\n        )}\n        disabled\n      >\n        <IconPlaceholder\n          lucide=\"GripHorizontalIcon\"\n          tabler=\"IconGripHorizontal\"\n          hugeicons=\"DragDropHorizontalIcon\"\n          phosphor=\"DotsSixIcon\"\n          remixicon=\"RiDraggable\"\n        />\n      </Button>\n    )\n  }\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon-sm\"\n      className={cn(\n        \"size-7 cursor-move opacity-70 hover:bg-transparent hover:opacity-100\",\n        className\n      )}\n      {...context.attributes}\n      {...context.listeners}\n    >\n      <IconPlaceholder\n        lucide=\"GripHorizontalIcon\"\n        tabler=\"IconGripHorizontal\"\n        hugeicons=\"DragDropHorizontalIcon\"\n        phosphor=\"DotsSixIcon\"\n        remixicon=\"RiDraggable\"\n      />\n    </Button>\n  )\n}\n\nfunction DataGridTableDndRow<TData>({ row }: { row: Row<TData> }) {\n  const {\n    transform,\n    transition,\n    setNodeRef,\n    isDragging,\n    attributes,\n    listeners,\n  } = useSortable({\n    id: row.id,\n  })\n\n  const style: CSSProperties = {\n    transform: CSS.Transform.toString(transform),\n    transition: transition,\n    opacity: isDragging ? 0.8 : 1,\n    zIndex: isDragging ? 1 : 0,\n    position: \"relative\",\n  }\n\n  return (\n    <SortableRowContext.Provider value={{ attributes, listeners }}>\n      <DataGridTableBodyRow\n        row={row}\n        dndRef={setNodeRef}\n        dndStyle={style}\n        key={row.id}\n      >\n        {row.getVisibleCells().map((cell: Cell<TData, unknown>, colIndex) => {\n          return (\n            <DataGridTableBodyRowCell cell={cell} key={colIndex}>\n              {flexRender(cell.column.columnDef.cell, cell.getContext())}\n            </DataGridTableBodyRowCell>\n          )\n        })}\n      </DataGridTableBodyRow>\n    </SortableRowContext.Provider>\n  )\n}\n\nfunction DataGridTableDndRows<TData>({\n  handleDragEnd,\n  dataIds,\n}: {\n  handleDragEnd: (event: DragEndEvent) => void\n  dataIds: UniqueIdentifier[]\n}) {\n  const { table, isLoading, props } = useDataGrid()\n  const pagination = table.getState().pagination\n  const tableContainerRef = useRef<HTMLDivElement>(null)\n\n  const sensors = useSensors(\n    useSensor(MouseSensor, {}),\n    useSensor(TouchSensor, {}),\n    useSensor(KeyboardSensor, {})\n  )\n\n  const modifiers = useMemo(() => {\n    const restrictToTableContainer: Modifier = ({\n      transform,\n      draggingNodeRect,\n    }) => {\n      if (!tableContainerRef.current || !draggingNodeRect) {\n        return transform\n      }\n\n      const containerRect = tableContainerRef.current.getBoundingClientRect()\n      const { x, y } = transform\n\n      const minX = containerRect.left - draggingNodeRect.left\n      const maxX = containerRect.right - draggingNodeRect.right\n      const minY = containerRect.top - draggingNodeRect.top\n      const maxY = containerRect.bottom - draggingNodeRect.bottom\n\n      return {\n        ...transform,\n        x: Math.max(minX, Math.min(maxX, x)),\n        y: Math.max(minY, Math.min(maxY, y)),\n      }\n    }\n\n    return [restrictToVerticalAxis, restrictToTableContainer]\n  }, [])\n\n  return (\n    <DndContext\n      id={useId()}\n      collisionDetection={closestCenter}\n      modifiers={modifiers}\n      onDragEnd={handleDragEnd}\n      sensors={sensors}\n    >\n      <div ref={tableContainerRef} className=\"relative\">\n        <DataGridTableBase>\n          <DataGridTableHead>\n            {table\n              .getHeaderGroups()\n              .map((headerGroup: HeaderGroup<TData>, index) => {\n                return (\n                  <DataGridTableHeadRow headerGroup={headerGroup} key={index}>\n                    {headerGroup.headers.map((header, index) => {\n                      const { column } = header\n\n                      return (\n                        <DataGridTableHeadRowCell header={header} key={index}>\n                          {header.isPlaceholder\n                            ? null\n                            : flexRender(\n                                header.column.columnDef.header,\n                                header.getContext()\n                              )}\n                          {props.tableLayout?.columnsResizable &&\n                            column.getCanResize() && (\n                              <DataGridTableHeadRowCellResize header={header} />\n                            )}\n                        </DataGridTableHeadRowCell>\n                      )\n                    })}\n                  </DataGridTableHeadRow>\n                )\n              })}\n          </DataGridTableHead>\n\n          {(props.tableLayout?.stripped || !props.tableLayout?.rowBorder) && (\n            <DataGridTableRowSpacer />\n          )}\n\n          <DataGridTableBody>\n            {props.loadingMode === \"skeleton\" &&\n            isLoading &&\n            pagination?.pageSize ? (\n              Array.from({ length: pagination.pageSize }).map((_, rowIndex) => (\n                <DataGridTableBodyRowSkeleton key={rowIndex}>\n                  {table.getVisibleFlatColumns().map((column, colIndex) => {\n                    return (\n                      <DataGridTableBodyRowSkeletonCell\n                        column={column}\n                        key={colIndex}\n                      >\n                        {column.columnDef.meta?.skeleton}\n                      </DataGridTableBodyRowSkeletonCell>\n                    )\n                  })}\n                </DataGridTableBodyRowSkeleton>\n              ))\n            ) : table.getRowModel().rows.length ? (\n              <SortableContext\n                items={dataIds}\n                strategy={verticalListSortingStrategy}\n              >\n                {table.getRowModel().rows.map((row: Row<TData>) => {\n                  return <DataGridTableDndRow row={row} key={row.id} />\n                })}\n              </SortableContext>\n            ) : (\n              <DataGridTableEmpty />\n            )}\n          </DataGridTableBody>\n        </DataGridTableBase>\n      </div>\n    </DndContext>\n  )\n}\n\nexport { DataGridTableDndRowHandle, DataGridTableDndRows }","target":"component/reui/data-grid/data-grid-table-dnd-rows.tsx"}]}