{"$schema":"https://ui.shadcn.com/schema/registry-item.json","name":"data-grid-table-dnd","type":"registry:ui","title":"Data Grid Table Dnd","description":"","dependencies":["@dnd-kit/core","@dnd-kit/sortable","@dnd-kit/utilities","@tanstack/react-table"],"registryDependencies":["button"],"files":[{"path":"data-grid-table-dnd.tsx","type":"registry:ui","content":"\"use client\"\n\nimport { CSSProperties, Fragment, useId, useRef } from \"react\"\nimport { useDataGrid } from \"@/components/reui/data-grid/data-grid\"\nimport {\n  DataGridTableBase,\n  DataGridTableBody,\n  DataGridTableBodyRow,\n  DataGridTableBodyRowCell,\n  DataGridTableBodyRowExpandded,\n  DataGridTableBodyRowSkeleton,\n  DataGridTableBodyRowSkeletonCell,\n  DataGridTableEmpty,\n  DataGridTableHead,\n  DataGridTableHeadRow,\n  DataGridTableHeadRowCell,\n  DataGridTableHeadRowCellResize,\n  DataGridTableRowSpacer,\n} from \"@/components/reui/data-grid/data-grid-table\"\nimport {\n  closestCenter,\n  DndContext,\n  KeyboardSensor,\n  Modifier,\n  MouseSensor,\n  TouchSensor,\n  useSensor,\n  useSensors,\n  type DragEndEvent,\n} from \"@dnd-kit/core\"\nimport {\n  horizontalListSortingStrategy,\n  SortableContext,\n  useSortable,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport {\n  Cell,\n  flexRender,\n  Header,\n  HeaderGroup,\n  Row,\n} from \"@tanstack/react-table\"\n\nimport { Button } from \"@/components/ui/button\"\nimport { IconPlaceholder } from \"@/app/(create)/components/icon-placeholder\"\n\nfunction DataGridTableDndHeader<TData>({\n  header,\n}: {\n  header: Header<TData, unknown>\n}) {\n  const { props } = useDataGrid()\n  const { column } = header\n\n  // Check if column ordering is enabled for this column\n  const canOrder =\n    (column.columnDef as { enableColumnOrdering?: boolean })\n      .enableColumnOrdering !== false\n\n  const {\n    attributes,\n    isDragging,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n  } = useSortable({\n    id: header.column.id,\n  })\n\n  const style: CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: CSS.Translate.toString(transform),\n    transition,\n    whiteSpace: \"nowrap\",\n    width: header.column.getSize(),\n    zIndex: isDragging ? 1 : 0,\n  }\n\n  return (\n    <DataGridTableHeadRowCell\n      header={header}\n      dndStyle={style}\n      dndRef={setNodeRef}\n    >\n      <div className=\"flex items-center justify-start gap-0.5\">\n        {canOrder && (\n          <Button\n            size=\"icon-sm\"\n            variant=\"ghost\"\n            className=\"-ms-2 size-6 cursor-move\"\n            {...attributes}\n            {...listeners}\n            aria-label=\"Drag to reorder\"\n          >\n            <IconPlaceholder\n              lucide=\"GripVerticalIcon\"\n              tabler=\"IconGripVertical\"\n              hugeicons=\"DragDropVerticalIcon\"\n              phosphor=\"DotsSixVerticalIcon\"\n              remixicon=\"RiDraggable\"\n              className=\"opacity-60 hover:opacity-100\"\n              aria-hidden=\"true\"\n            />\n          </Button>\n        )}\n        <span className=\"grow truncate\">\n          {header.isPlaceholder\n            ? null\n            : flexRender(header.column.columnDef.header, header.getContext())}\n        </span>\n        {props.tableLayout?.columnsResizable && column.getCanResize() && (\n          <DataGridTableHeadRowCellResize header={header} />\n        )}\n      </div>\n    </DataGridTableHeadRowCell>\n  )\n}\n\nfunction DataGridTableDndCell<TData>({ cell }: { cell: Cell<TData, unknown> }) {\n  const { isDragging, setNodeRef, transform, transition } = useSortable({\n    id: cell.column.id,\n  })\n\n  const style: CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: CSS.Translate.toString(transform),\n    transition,\n    width: cell.column.getSize(),\n    zIndex: isDragging ? 1 : 0,\n  }\n\n  return (\n    <DataGridTableBodyRowCell cell={cell} dndStyle={style} dndRef={setNodeRef}>\n      {flexRender(cell.column.columnDef.cell, cell.getContext())}\n    </DataGridTableBodyRowCell>\n  )\n}\n\nfunction DataGridTableDnd<TData>({\n  handleDragEnd,\n}: {\n  handleDragEnd: (event: DragEndEvent) => void\n}) {\n  const { table, isLoading, props } = useDataGrid()\n  const pagination = table.getState().pagination\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  const sensors = useSensors(\n    useSensor(MouseSensor, {}),\n    useSensor(TouchSensor, {}),\n    useSensor(KeyboardSensor, {})\n  )\n\n  // Custom modifier to restrict dragging within table bounds with edge offset\n  const restrictToTableBounds: Modifier = ({ draggingNodeRect, transform }) => {\n    if (!draggingNodeRect || !containerRef.current) {\n      return { ...transform, y: 0 }\n    }\n\n    const containerRect = containerRef.current.getBoundingClientRect()\n    const edgeOffset = 0\n\n    const minX = containerRect.left - draggingNodeRect.left - edgeOffset\n    const maxX =\n      containerRect.right -\n      draggingNodeRect.left -\n      draggingNodeRect.width +\n      edgeOffset\n\n    return {\n      ...transform,\n      x: Math.min(Math.max(transform.x, minX), maxX),\n      y: 0, // Lock vertical movement\n    }\n  }\n\n  return (\n    <DndContext\n      collisionDetection={closestCenter}\n      id={useId()}\n      modifiers={[restrictToTableBounds]}\n      onDragEnd={handleDragEnd}\n      sensors={sensors}\n    >\n      <div ref={containerRef}>\n        <DataGridTableBase>\n          <DataGridTableHead>\n            {table\n              .getHeaderGroups()\n              .map((headerGroup: HeaderGroup<TData>, index) => {\n                return (\n                  <DataGridTableHeadRow headerGroup={headerGroup} key={index}>\n                    <SortableContext\n                      items={table.getState().columnOrder}\n                      strategy={horizontalListSortingStrategy}\n                    >\n                      {headerGroup.headers.map((header) => (\n                        <DataGridTableDndHeader\n                          header={header}\n                          key={header.id}\n                        />\n                      ))}\n                    </SortableContext>\n                  </DataGridTableHeadRow>\n                )\n              })}\n          </DataGridTableHead>\n\n          {(props.tableLayout?.stripped || !props.tableLayout?.rowBorder) && (\n            <DataGridTableRowSpacer />\n          )}\n\n          <DataGridTableBody>\n            {props.loadingMode === \"skeleton\" &&\n            isLoading &&\n            pagination?.pageSize ? (\n              Array.from({ length: pagination.pageSize }).map((_, rowIndex) => (\n                <DataGridTableBodyRowSkeleton key={rowIndex}>\n                  {table.getVisibleFlatColumns().map((column, colIndex) => {\n                    return (\n                      <DataGridTableBodyRowSkeletonCell\n                        column={column}\n                        key={colIndex}\n                      >\n                        {column.columnDef.meta?.skeleton}\n                      </DataGridTableBodyRowSkeletonCell>\n                    )\n                  })}\n                </DataGridTableBodyRowSkeleton>\n              ))\n            ) : table.getRowModel().rows.length ? (\n              table.getRowModel().rows.map((row: Row<TData>) => {\n                return (\n                  <Fragment key={row.id}>\n                    <DataGridTableBodyRow row={row}>\n                      {row\n                        .getVisibleCells()\n                        .map((cell: Cell<TData, unknown>) => {\n                          return (\n                            <SortableContext\n                              key={cell.id}\n                              items={table.getState().columnOrder}\n                              strategy={horizontalListSortingStrategy}\n                            >\n                              <DataGridTableDndCell cell={cell} />\n                            </SortableContext>\n                          )\n                        })}\n                    </DataGridTableBodyRow>\n                    {row.getIsExpanded() && (\n                      <DataGridTableBodyRowExpandded row={row} />\n                    )}\n                  </Fragment>\n                )\n              })\n            ) : (\n              <DataGridTableEmpty />\n            )}\n          </DataGridTableBody>\n        </DataGridTableBase>\n      </div>\n    </DndContext>\n  )\n}\n\nexport { DataGridTableDnd }","target":"component/reui/data-grid/data-grid-table-dnd.tsx"}]}