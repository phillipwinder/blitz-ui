{"$schema":"https://ui.shadcn.com/schema/registry-item.json","name":"sortable","type":"registry:ui","title":"Sortable","description":"","dependencies":["@base-ui/react","@dnd-kit/core","@dnd-kit/sortable","@dnd-kit/utilities"],"registryDependencies":[],"files":[{"path":"sortable.tsx","type":"registry:ui","content":"/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\"\n\nimport * as React from \"react\"\nimport {\n  Children,\n  cloneElement,\n  createContext,\n  CSSProperties,\n  isValidElement,\n  ReactElement,\n  ReactNode,\n  useCallback,\n  useContext,\n  useLayoutEffect,\n  useMemo,\n  useState,\n} from \"react\"\nimport { mergeProps } from \"@base-ui/react/merge-props\"\nimport { useRender } from \"@base-ui/react/use-render\"\nimport {\n  defaultDropAnimationSideEffects,\n  DndContext,\n  DragEndEvent,\n  DragOverlay,\n  DragStartEvent,\n  DropAnimation,\n  KeyboardSensor,\n  MeasuringStrategy,\n  Modifiers,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n  type DraggableSyntheticListeners,\n} from \"@dnd-kit/core\"\nimport {\n  arrayMove,\n  defaultAnimateLayoutChanges,\n  rectSortingStrategy,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n  type AnimateLayoutChanges,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport { createPortal } from \"react-dom\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Sortable Item Context\nconst SortableItemContext = createContext<{\n  listeners: DraggableSyntheticListeners | undefined\n  isDragging?: boolean\n  disabled?: boolean\n}>({\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n})\n\nconst IsOverlayContext = createContext(false)\n\nconst SortableInternalContext = createContext<{\n  activeId: UniqueIdentifier | null\n  modifiers?: Modifiers\n}>({\n  activeId: null,\n  modifiers: undefined,\n})\n\nconst animateLayoutChanges: AnimateLayoutChanges = (args) =>\n  defaultAnimateLayoutChanges({ ...args, wasDragging: true })\n\nconst dropAnimationConfig: DropAnimation = {\n  sideEffects: defaultDropAnimationSideEffects({\n    styles: {\n      active: {\n        opacity: \"0.4\",\n      },\n    },\n  }),\n}\n\n// Multipurpose Sortable Component\nexport interface SortableRootProps<T> extends Omit<\n  useRender.ComponentProps<\"div\">,\n  \"onDragStart\" | \"onDragEnd\" | \"children\"\n> {\n  value: T[]\n  onValueChange: (value: T[]) => void\n  getItemValue: (item: T) => string\n  children: ReactNode\n  onMove?: (event: {\n    event: DragEndEvent\n    activeIndex: number\n    overIndex: number\n  }) => void\n  strategy?: \"horizontal\" | \"vertical\" | \"grid\"\n  onDragStart?: (event: DragStartEvent) => void\n  onDragEnd?: (event: DragEndEvent) => void\n  modifiers?: Modifiers\n}\n\nfunction Sortable<T>({\n  value,\n  onValueChange,\n  getItemValue,\n  className,\n  render,\n  onMove,\n  strategy = \"vertical\",\n  onDragStart,\n  onDragEnd,\n  modifiers,\n  children,\n  ...props\n}: SortableRootProps<T>) {\n  const [activeId, setActiveId] = useState<UniqueIdentifier | null>(null)\n  const [mounted, setMounted] = useState(false)\n\n  useLayoutEffect(() => setMounted(true), [])\n\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 10,\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  )\n\n  const handleDragStart = useCallback(\n    (event: DragStartEvent) => {\n      setActiveId(event.active.id)\n      onDragStart?.(event)\n    },\n    [onDragStart]\n  )\n\n  const handleDragEnd = useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event\n      setActiveId(null)\n      onDragEnd?.(event)\n\n      if (!over) return\n\n      // Handle item reordering\n      const activeIndex = value.findIndex(\n        (item: T) => getItemValue(item) === active.id\n      )\n      const overIndex = value.findIndex(\n        (item: T) => getItemValue(item) === over.id\n      )\n\n      if (activeIndex !== overIndex) {\n        if (onMove) {\n          onMove({ event, activeIndex, overIndex })\n        } else {\n          const newValue = arrayMove(value, activeIndex, overIndex)\n          onValueChange(newValue)\n        }\n      }\n    },\n    [value, getItemValue, onValueChange, onMove, onDragEnd]\n  )\n\n  const handleDragCancel = useCallback(() => {\n    setActiveId(null)\n  }, [])\n\n  const getStrategy = () => {\n    switch (strategy) {\n      case \"horizontal\":\n        return rectSortingStrategy\n      case \"grid\":\n        return rectSortingStrategy\n      case \"vertical\":\n      default:\n        return verticalListSortingStrategy\n    }\n  }\n\n  const itemIds = useMemo(() => value.map(getItemValue), [value, getItemValue])\n\n  const contextValue = useMemo(\n    () => ({ activeId, modifiers }),\n    [activeId, modifiers]\n  )\n\n  const defaultProps = {\n    \"data-slot\": \"sortable\",\n    \"data-dragging\": activeId !== null,\n    className: cn(activeId !== null && \"cursor-grabbing!\", className),\n    children,\n  }\n\n  // Find the active child for the overlay\n  const overlayContent = useMemo(() => {\n    if (!activeId) return null\n    let result: ReactNode = null\n    Children.forEach(children, (child) => {\n      if (isValidElement(child) && (child.props as any).value === activeId) {\n        result = cloneElement(child as ReactElement<any>, {\n          ...(child.props as any),\n          className: cn((child.props as any).className, \"z-50 shadow-lg\"),\n        })\n      }\n    })\n    return result\n  }, [activeId, children])\n\n  return (\n    <SortableInternalContext.Provider value={contextValue}>\n      <DndContext\n        sensors={sensors}\n        modifiers={modifiers}\n        measuring={{\n          droppable: {\n            strategy: MeasuringStrategy.Always,\n          },\n        }}\n        onDragStart={handleDragStart}\n        onDragEnd={handleDragEnd}\n        onDragCancel={handleDragCancel}\n      >\n        <SortableContext items={itemIds} strategy={getStrategy()}>\n          {useRender({\n            defaultTagName: \"div\",\n            render,\n            props: mergeProps<\"div\">(defaultProps, props),\n          })}\n        </SortableContext>\n        {mounted &&\n          createPortal(\n            <DragOverlay\n              dropAnimation={dropAnimationConfig}\n              modifiers={modifiers}\n              className={cn(\"z-50\", activeId && \"cursor-grabbing\")}\n            >\n              <IsOverlayContext.Provider value={true}>\n                {overlayContent}\n              </IsOverlayContext.Provider>\n            </DragOverlay>,\n            document.body\n          )}\n      </DndContext>\n    </SortableInternalContext.Provider>\n  )\n}\n\nexport interface SortableItemProps extends useRender.ComponentProps<\"div\"> {\n  value: string\n  disabled?: boolean\n}\n\nfunction SortableItem({\n  value,\n  className,\n  render,\n  disabled,\n  ...props\n}: SortableItemProps) {\n  const isOverlay = useContext(IsOverlayContext)\n\n  if (isOverlay) {\n    const defaultProps = {\n      \"data-slot\": \"sortable-item\",\n      \"data-value\": value,\n      \"data-dragging\": true,\n      className: cn(className),\n      children: props.children,\n    }\n\n    return (\n      <SortableItemContext.Provider\n        value={{ listeners: undefined, isDragging: true, disabled: false }}\n      >\n        {useRender({\n          defaultTagName: \"div\",\n          render,\n          props: mergeProps<\"div\">(defaultProps, props),\n        })}\n      </SortableItemContext.Provider>\n    )\n  }\n\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n    animateLayoutChanges,\n  })\n\n  const style = {\n    transition,\n    transform: CSS.Transform.toString(transform),\n  } as CSSProperties\n\n  const defaultProps = {\n    \"data-slot\": \"sortable-item\",\n    \"data-value\": value,\n    \"data-dragging\": isSortableDragging,\n    \"data-disabled\": disabled,\n    ref: setNodeRef,\n    style,\n    ...attributes,\n    className: cn(\n      isSortableDragging && \"opacity-50 z-50\",\n      disabled && \"opacity-50\",\n      className\n    ),\n    children: props.children,\n  }\n\n  return (\n    <SortableItemContext.Provider\n      value={{ listeners, isDragging: isSortableDragging, disabled }}\n    >\n      {useRender({\n        defaultTagName: \"div\",\n        render,\n        props: mergeProps<\"div\">(defaultProps, props),\n      })}\n    </SortableItemContext.Provider>\n  )\n}\n\nexport interface SortableItemHandleProps extends useRender.ComponentProps<\"div\"> {\n  cursor?: boolean\n}\n\nfunction SortableItemHandle({\n  className,\n  render,\n  cursor = true,\n  ...props\n}: SortableItemHandleProps) {\n  const { listeners, isDragging, disabled } = useContext(SortableItemContext)\n\n  const defaultProps = {\n    \"data-slot\": \"sortable-item-handle\",\n    \"data-dragging\": isDragging,\n    \"data-disabled\": disabled,\n    ...listeners,\n    className: cn(\n      cursor && (isDragging ? \"cursor-grabbing!\" : \"cursor-grab!\"),\n      className\n    ),\n    children: props.children,\n  }\n\n  return useRender({\n    defaultTagName: \"div\",\n    render,\n    props: mergeProps<\"div\">(defaultProps, props),\n  })\n}\n\nexport interface SortableOverlayProps extends Omit<\n  React.ComponentProps<typeof DragOverlay>,\n  \"children\"\n> {\n  children?: ReactNode | ((params: { value: UniqueIdentifier }) => ReactNode)\n}\n\nfunction SortableOverlay({\n  children,\n  className,\n  ...props\n}: SortableOverlayProps) {\n  const { activeId, modifiers } = useContext(SortableInternalContext)\n  const [mounted, setMounted] = useState(false)\n\n  useLayoutEffect(() => setMounted(true), [])\n\n  const content =\n    activeId && children\n      ? typeof children === \"function\"\n        ? children({ value: activeId })\n        : children\n      : null\n\n  if (!mounted) return null\n\n  return createPortal(\n    <DragOverlay\n      dropAnimation={dropAnimationConfig}\n      modifiers={modifiers}\n      className={cn(\"z-50\", activeId && \"cursor-grabbing\", className)}\n      {...props}\n    >\n      <IsOverlayContext.Provider value={true}>\n        {content}\n      </IsOverlayContext.Provider>\n    </DragOverlay>,\n    document.body\n  )\n}\n\nexport { Sortable, SortableItem, SortableItemHandle, SortableOverlay }","target":"components/reui/sortable.tsx"}]}