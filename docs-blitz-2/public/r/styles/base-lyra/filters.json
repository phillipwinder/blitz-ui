{"$schema":"https://ui.shadcn.com/schema/registry-item.json","name":"filters","type":"registry:ui","title":"Filters","description":"","dependencies":["@base-ui/react","class-variance-authority"],"registryDependencies":["button","button-group","dropdown-menu","input","input-group","kbd","scroll-area","tooltip"],"files":[{"path":"filters.tsx","type":"registry:ui","content":"\"use client\"\n\nimport type React from \"react\"\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useId,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { useRender } from \"@base-ui/react/use-render\"\nimport { cva } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  ButtonGroup,\n  ButtonGroupText,\n} from \"@/components/ui/button-group\"\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  InputGroup,\n  InputGroupAddon,\n  InputGroupButton,\n  InputGroupInput,\n  InputGroupText,\n} from \"@/components/ui/input-group\"\nimport { Kbd } from \"@/components/ui/kbd\"\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\nimport { IconPlaceholder } from \"@/app/(create)/components/icon-placeholder\"\n\n// i18n Configuration Interface\nexport interface FilterI18nConfig {\n  // UI Labels\n  addFilter: string\n  searchFields: string\n  noFieldsFound: string\n  noResultsFound: string\n  select: string\n  true: string\n  false: string\n  min: string\n  max: string\n  to: string\n  typeAndPressEnter: string\n  selected: string\n  selectedCount: string\n  percent: string\n  defaultCurrency: string\n  defaultColor: string\n  addFilterTitle: string\n\n  // Operators\n  operators: {\n    is: string\n    isNot: string\n    isAnyOf: string\n    isNotAnyOf: string\n    includesAll: string\n    excludesAll: string\n    before: string\n    after: string\n    between: string\n    notBetween: string\n    contains: string\n    notContains: string\n    startsWith: string\n    endsWith: string\n    isExactly: string\n    equals: string\n    notEquals: string\n    greaterThan: string\n    lessThan: string\n    overlaps: string\n    includes: string\n    excludes: string\n    includesAllOf: string\n    includesAnyOf: string\n    empty: string\n    notEmpty: string\n  }\n\n  // Placeholders\n  placeholders: {\n    enterField: (fieldType: string) => string\n    selectField: string\n    searchField: (fieldName: string) => string\n    enterKey: string\n    enterValue: string\n  }\n\n  // Helper functions\n  helpers: {\n    formatOperator: (operator: string) => string\n  }\n\n  // Validation\n  validation: {\n    invalidEmail: string\n    invalidUrl: string\n    invalidTel: string\n    invalid: string\n  }\n}\n\n// Default English i18n configuration\nexport const DEFAULT_I18N: FilterI18nConfig = {\n  // UI Labels\n  addFilter: \"Filter\",\n  searchFields: \"Filter...\",\n  noFieldsFound: \"No filters found.\",\n  noResultsFound: \"No results found.\",\n  select: \"Select...\",\n  true: \"True\",\n  false: \"False\",\n  min: \"Min\",\n  max: \"Max\",\n  to: \"to\",\n  typeAndPressEnter: \"Type and press Enter to add tag\",\n  selected: \"selected\",\n  selectedCount: \"selected\",\n  percent: \"%\",\n  defaultCurrency: \"$\",\n  defaultColor: \"#000000\",\n  addFilterTitle: \"Add filter\",\n\n  // Operators\n  operators: {\n    is: \"is\",\n    isNot: \"is not\",\n    isAnyOf: \"is any of\",\n    isNotAnyOf: \"is not any of\",\n    includesAll: \"includes all\",\n    excludesAll: \"excludes all\",\n    before: \"before\",\n    after: \"after\",\n    between: \"between\",\n    notBetween: \"not between\",\n    contains: \"contains\",\n    notContains: \"does not contain\",\n    startsWith: \"starts with\",\n    endsWith: \"ends with\",\n    isExactly: \"is exactly\",\n    equals: \"equals\",\n    notEquals: \"not equals\",\n    greaterThan: \"greater than\",\n    lessThan: \"less than\",\n    overlaps: \"overlaps\",\n    includes: \"includes\",\n    excludes: \"excludes\",\n    includesAllOf: \"includes all of\",\n    includesAnyOf: \"includes any of\",\n    empty: \"is empty\",\n    notEmpty: \"is not empty\",\n  },\n\n  // Placeholders\n  placeholders: {\n    enterField: (fieldType: string) => `Enter ${fieldType}...`,\n    selectField: \"Select...\",\n    searchField: (fieldName: string) => `Search ${fieldName.toLowerCase()}...`,\n    enterKey: \"Enter key...\",\n    enterValue: \"Enter value...\",\n  },\n\n  // Helper functions\n  helpers: {\n    formatOperator: (operator: string) => operator.replace(/_/g, \" \"),\n  },\n\n  // Validation\n  validation: {\n    invalidEmail: \"Invalid email format\",\n    invalidUrl: \"Invalid URL format\",\n    invalidTel: \"Invalid phone format\",\n    invalid: \"Invalid input format\",\n  },\n}\n\n// Context for all Filter component props\ninterface FilterContextValue {\n  variant: \"solid\" | \"default\"\n  size: \"sm\" | \"default\" | \"lg\"\n  radius: \"default\" | \"full\"\n  i18n: FilterI18nConfig\n  className?: string\n  showSearchInput?: boolean\n  trigger?: React.ReactNode\n  allowMultiple?: boolean\n}\n\nconst FilterContext = createContext<FilterContextValue>({\n  variant: \"default\",\n  size: \"default\",\n  radius: \"default\",\n  i18n: DEFAULT_I18N,\n  className: undefined,\n  showSearchInput: true,\n  trigger: undefined,\n  allowMultiple: true,\n})\n\nconst useFilterContext = () => useContext(FilterContext)\n\n// Container variant for filters wrapper\nconst filtersContainerVariants = cva(\"flex flex-wrap items-center\", {\n  variants: {\n    variant: {\n      solid: \"gap-2\",\n      default: \"\",\n    },\n    size: {\n      sm: \"gap-1.5\",\n      default: \"gap-2.5\",\n      lg: \"gap-3.5\",\n    },\n  },\n  defaultVariants: {\n    variant: \"default\",\n    size: \"default\",\n  },\n})\n\nfunction FilterInput<T = unknown>({\n  field,\n  onBlur,\n  onKeyDown,\n  className,\n  ...props\n}: React.InputHTMLAttributes<HTMLInputElement> & {\n  className?: string\n  field?: FilterFieldConfig<T>\n}) {\n  const context = useFilterContext()\n  const [isValid, setIsValid] = useState(true)\n  const [validationMessage, setValidationMessage] = useState(\"\")\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  useEffect(() => {\n    if (props.autoFocus) {\n      const timer = setTimeout(() => {\n        inputRef.current?.focus()\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [props.autoFocus])\n\n  // Validation function to check if input matches pattern\n  const validateInput = (value: string, pattern?: string): boolean => {\n    if (!pattern || !value) return true\n    const regex = new RegExp(pattern)\n    return regex.test(value)\n  }\n\n  // Get validation message for field type\n  const getValidationMessage = (): string => {\n    return context.i18n.validation.invalid\n  }\n\n  // Handle blur event - validate when user leaves input\n  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    const value = e.target.value\n    const pattern = field?.pattern || props.pattern\n\n    // Only validate if there's a value and (pattern or validation function)\n    if (value && (pattern || field?.validation)) {\n      let valid = true\n      let customMessage = \"\"\n\n      // If there's a custom validation function, use it\n      if (field?.validation) {\n        const result = field.validation(value)\n        // Handle both boolean and object return types\n        if (typeof result === \"boolean\") {\n          valid = result\n        } else {\n          valid = result.valid\n          customMessage = result.message || \"\"\n        }\n      } else if (pattern) {\n        // Use pattern validation\n        valid = validateInput(value, pattern)\n      }\n\n      setIsValid(valid)\n      setValidationMessage(valid ? \"\" : customMessage || getValidationMessage())\n    } else {\n      // Reset validation state for empty values or no validation\n      setIsValid(true)\n      setValidationMessage(\"\")\n    }\n\n    // Call the original onBlur if provided\n    onBlur?.(e)\n  }\n\n  // Handle keydown event - hide validation error when user starts typing\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    // Hide validation error when user starts typing (any key except special keys)\n    if (\n      !isValid &&\n      ![\n        \"Tab\",\n        \"Escape\",\n        \"Enter\",\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n      ].includes(e.key)\n    ) {\n      setIsValid(true)\n      setValidationMessage(\"\")\n    }\n\n    // Call the original onKeyDown if provided\n    onKeyDown?.(e)\n  }\n\n  return (\n    <InputGroup className={cn(\"w-36\", className)}>\n      {field?.prefix && (\n        <InputGroupAddon>\n          <InputGroupText>{field.prefix}</InputGroupText>\n        </InputGroupAddon>\n      )}\n      <InputGroupInput\n        ref={inputRef}\n        aria-invalid={!isValid}\n        aria-describedby={\n          !isValid && validationMessage\n            ? `${field?.key || \"input\"}-error`\n            : undefined\n        }\n        onBlur={handleBlur}\n        onKeyDown={handleKeyDown}\n        {...props}\n      />\n      {!isValid && validationMessage && (\n        <InputGroupAddon align=\"inline-end\">\n          <Tooltip>\n            <TooltipTrigger render={<InputGroupButton size=\"icon-xs\" />}>\n              <IconPlaceholder\n                lucide=\"AlertCircleIcon\"\n                tabler=\"IconAlertCircle\"\n                hugeicons=\"AlertCircleIcon\"\n                phosphor=\"WarningCircleIcon\"\n                remixicon=\"RiErrorWarningLine\"\n                className=\"text-destructive size-3.5\"\n              />\n            </TooltipTrigger>\n            <TooltipContent>\n              <p className=\"text-sm\">{validationMessage}</p>\n            </TooltipContent>\n          </Tooltip>\n        </InputGroupAddon>\n      )}\n\n      {field?.suffix && (\n        <InputGroupAddon align=\"inline-end\">\n          <InputGroupText>{field.suffix}</InputGroupText>\n        </InputGroupAddon>\n      )}\n    </InputGroup>\n  )\n}\n\ninterface FilterRemoveButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  icon?: React.ReactNode\n}\n\nfunction FilterRemoveButton({\n  className,\n  icon = (\n    <IconPlaceholder\n      lucide=\"XIcon\"\n      tabler=\"IconX\"\n      hugeicons=\"Cancel01Icon\"\n      phosphor=\"XIcon\"\n      remixicon=\"RiCloseLine\"\n    />\n  ),\n  ...props\n}: FilterRemoveButtonProps) {\n  const context = useFilterContext()\n\n  const sizeMap = {\n    sm: \"sm\" as const,\n    default: \"sm\" as const,\n    lg: \"default\" as const,\n  }\n\n  return (\n    <Button\n      variant=\"outline\"\n      size={\n        context.size === \"sm\"\n          ? \"icon-sm\"\n          : context.size === \"lg\"\n            ? \"icon-lg\"\n            : \"icon\"\n      }\n      {...props}\n    >\n      {icon}\n    </Button>\n  )\n}\n\n// Generic types for flexible filter system\nexport interface FilterOption<T = unknown> {\n  value: T\n  label: string\n  icon?: React.ReactNode\n  metadata?: Record<string, unknown>\n  className?: string\n}\n\nexport interface FilterOperator {\n  value: string\n  label: string\n  supportsMultiple?: boolean\n}\n\n// Custom renderer props interface\nexport interface CustomRendererProps<T = unknown> {\n  field: FilterFieldConfig<T>\n  values: T[]\n  onChange: (values: T[]) => void\n  operator: string\n}\n\n// Grouped field configuration interface\nexport interface FilterFieldGroup<T = unknown> {\n  group?: string\n  fields: FilterFieldConfig<T>[]\n}\n\n// Union type for both flat and grouped field configurations\nexport type FilterFieldsConfig<T = unknown> =\n  | FilterFieldConfig<T>[]\n  | FilterFieldGroup<T>[]\n\nexport interface FilterFieldConfig<T = unknown> {\n  key?: string\n  label?: string\n  icon?: React.ReactNode\n  type?: \"select\" | \"multiselect\" | \"text\" | \"custom\" | \"separator\"\n  // Group-level configuration\n  group?: string\n  fields?: FilterFieldConfig<T>[]\n  // Field-specific options\n  options?: FilterOption<T>[]\n  operators?: FilterOperator[]\n  customRenderer?: (props: CustomRendererProps<T>) => React.ReactNode\n  customValueRenderer?: (\n    values: T[],\n    options: FilterOption<T>[]\n  ) => React.ReactNode\n  placeholder?: string\n  searchable?: boolean\n  maxSelections?: number\n  min?: number\n  max?: number\n  step?: number\n  prefix?: string | React.ReactNode\n  suffix?: string | React.ReactNode\n  pattern?: string\n  validation?: (\n    value: unknown\n  ) => boolean | { valid: boolean; message?: string }\n  allowCustomValues?: boolean\n  className?: string\n  menuPopupClassName?: string\n  // Grouping options (legacy support)\n  groupLabel?: string\n  // Boolean field options\n  onLabel?: string\n  offLabel?: string\n  // Input event handlers\n  onInputChange?: (e: React.ChangeEvent<HTMLInputElement>) => void\n  // Default operator to use when creating a filter for this field\n  defaultOperator?: string\n  // Controlled values support for this field\n  value?: T[]\n  onValueChange?: (values: T[]) => void\n}\n\n// Helper functions to handle both flat and grouped field configurations\nconst isFieldGroup = <T = unknown,>(\n  item: FilterFieldConfig<T> | FilterFieldGroup<T>\n): item is FilterFieldGroup<T> => {\n  return \"fields\" in item && Array.isArray(item.fields)\n}\n\n// Helper function to check if a FilterFieldConfig is a group-level configuration\nconst isGroupLevelField = <T = unknown,>(\n  field: FilterFieldConfig<T>\n): boolean => {\n  return Boolean(field.group && field.fields)\n}\n\nconst flattenFields = <T = unknown,>(\n  fields: FilterFieldsConfig<T>\n): FilterFieldConfig<T>[] => {\n  return fields.reduce<FilterFieldConfig<T>[]>((acc, item) => {\n    if (isFieldGroup(item)) {\n      return [...acc, ...item.fields]\n    }\n    // Handle group-level fields (new structure)\n    if (isGroupLevelField(item)) {\n      return [...acc, ...item.fields!]\n    }\n    return [...acc, item]\n  }, [])\n}\n\nconst getFieldsMap = <T = unknown,>(\n  fields: FilterFieldsConfig<T>\n): Record<string, FilterFieldConfig<T>> => {\n  const flatFields = flattenFields(fields)\n  return flatFields.reduce(\n    (acc, field) => {\n      // Only add fields that have a key (skip group-level configurations)\n      if (field.key) {\n        acc[field.key] = field\n      }\n      return acc\n    },\n    {} as Record<string, FilterFieldConfig<T>>\n  )\n}\n\n// Helper function to create operators from i18n config\nconst createOperatorsFromI18n = (\n  i18n: FilterI18nConfig\n): Record<string, FilterOperator[]> => ({\n  select: [\n    { value: \"is\", label: i18n.operators.is },\n    { value: \"is_not\", label: i18n.operators.isNot },\n    { value: \"empty\", label: i18n.operators.empty },\n    { value: \"not_empty\", label: i18n.operators.notEmpty },\n  ],\n  multiselect: [\n    { value: \"is_any_of\", label: i18n.operators.isAnyOf },\n    { value: \"is_not_any_of\", label: i18n.operators.isNotAnyOf },\n    { value: \"includes_all\", label: i18n.operators.includesAll },\n    { value: \"excludes_all\", label: i18n.operators.excludesAll },\n    { value: \"empty\", label: i18n.operators.empty },\n    { value: \"not_empty\", label: i18n.operators.notEmpty },\n  ],\n  text: [\n    { value: \"contains\", label: i18n.operators.contains },\n    { value: \"not_contains\", label: i18n.operators.notContains },\n    { value: \"starts_with\", label: i18n.operators.startsWith },\n    { value: \"ends_with\", label: i18n.operators.endsWith },\n    { value: \"is\", label: i18n.operators.isExactly },\n    { value: \"empty\", label: i18n.operators.empty },\n    { value: \"not_empty\", label: i18n.operators.notEmpty },\n  ],\n  custom: [\n    { value: \"is\", label: i18n.operators.is },\n    { value: \"after\", label: i18n.operators.after },\n    { value: \"is\", label: i18n.operators.is },\n    { value: \"between\", label: i18n.operators.between },\n    { value: \"empty\", label: i18n.operators.empty },\n    { value: \"not_empty\", label: i18n.operators.notEmpty },\n  ],\n})\n\n// Default operators for different field types (using default i18n)\nexport const DEFAULT_OPERATORS: Record<string, FilterOperator[]> =\n  createOperatorsFromI18n(DEFAULT_I18N)\n\n// Helper function to get operators for a field\nconst getOperatorsForField = <T = unknown,>(\n  field: FilterFieldConfig<T>,\n  values: T[],\n  i18n: FilterI18nConfig\n): FilterOperator[] => {\n  if (field.operators) return field.operators\n\n  const operators = createOperatorsFromI18n(i18n)\n\n  // Determine field type for operator selection\n  let fieldType = field.type || \"select\"\n\n  // If it's a select field but has multiple values, treat as multiselect\n  if (fieldType === \"select\" && values.length > 1) {\n    fieldType = \"multiselect\"\n  }\n\n  // If it's a multiselect field or has multiselect operators, use multiselect operators\n  if (fieldType === \"multiselect\" || field.type === \"multiselect\") {\n    return operators.multiselect\n  }\n\n  return operators[fieldType] || operators.select\n}\n\ninterface FilterOperatorDropdownProps<T = unknown> {\n  field: FilterFieldConfig<T>\n  operator: string\n  values: T[]\n  onChange: (operator: string) => void\n}\n\nfunction FilterOperatorDropdown<T = unknown>({\n  field,\n  operator,\n  values,\n  onChange,\n}: FilterOperatorDropdownProps<T>) {\n  const context = useFilterContext()\n  const operators = getOperatorsForField(field, values, context.i18n)\n\n  // Find the operator label, with fallback to formatted operator name\n  const operatorLabel =\n    operators.find((op) => op.value === operator)?.label ||\n    context.i18n.helpers.formatOperator(operator)\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger\n        render={\n          <Button\n            variant=\"outline\"\n            size={context.size}\n            className=\"text-muted-foreground hover:text-foreground\"\n          >\n            {operatorLabel}\n          </Button>\n        }\n      />\n      <DropdownMenuContent align=\"start\" className=\"w-fit min-w-fit\">\n        {operators.map((op) => (\n          <DropdownMenuItem\n            key={op.value}\n            onClick={() => onChange(op.value)}\n            className={cn(\n              \"data-highlighted:bg-accent data-highlighted:text-accent-foreground flex items-center justify-between\"\n            )}\n          >\n            <span>{op.label}</span>\n            <IconPlaceholder\n              lucide=\"CheckIcon\"\n              tabler=\"IconCheck\"\n              hugeicons=\"Tick02Icon\"\n              phosphor=\"CheckIcon\"\n              remixicon=\"RiCheckLine\"\n              className={cn(\n                \"text-primary ms-auto\",\n                op.value === operator ? \"opacity-100\" : \"opacity-0\"\n              )}\n            />\n          </DropdownMenuItem>\n        ))}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  )\n}\n\ninterface FilterValueSelectorProps<T = unknown> {\n  field: FilterFieldConfig<T>\n  values: T[]\n  onChange: (values: T[]) => void\n  operator: string\n  autoFocus?: boolean\n}\n\ninterface SelectOptionsPopoverProps<T = unknown> {\n  field: FilterFieldConfig<T>\n  values: T[]\n  onChange: (values: T[]) => void\n  onClose?: () => void\n  inline?: boolean\n}\n\nfunction SelectOptionsPopover<T = unknown>({\n  field,\n  values,\n  onChange,\n  onClose,\n  inline = false,\n}: SelectOptionsPopoverProps<T>) {\n  const [open, setOpen] = useState(false)\n  const [searchInput, setSearchInput] = useState(\"\")\n  const [highlightedIndex, setHighlightedIndex] = useState(-1)\n  const inputRef = useRef<HTMLInputElement>(null)\n  const context = useFilterContext()\n  const baseId = useId()\n\n  useEffect(() => {\n    if (open) {\n      inputRef.current?.focus()\n    }\n  }, [open])\n\n  useEffect(() => {\n    setHighlightedIndex(-1)\n  }, [searchInput, open])\n\n  useEffect(() => {\n    if (highlightedIndex >= 0 && open) {\n      const element = document.getElementById(\n        `${baseId}-item-${highlightedIndex}`\n      )\n      element?.scrollIntoView({ block: \"nearest\" })\n    }\n  }, [highlightedIndex, open, baseId])\n\n  const isMultiSelect = field.type === \"multiselect\" || values.length > 1\n  const effectiveValues =\n    (field.value !== undefined ? (field.value as T[]) : values) || []\n\n  const selectedOptions =\n    field.options?.filter((opt) => effectiveValues.includes(opt.value)) || []\n  const unselectedOptions =\n    field.options?.filter((opt) => !effectiveValues.includes(opt.value)) || []\n\n  // Filter options based on search input\n  const filteredSelectedOptions = selectedOptions // Keep all selected visible\n  const filteredUnselectedOptions = unselectedOptions.filter((opt) =>\n    opt.label.toLowerCase().includes(searchInput.toLowerCase())\n  )\n\n  const allFilteredOptions = useMemo(\n    () => [...filteredSelectedOptions, ...filteredUnselectedOptions],\n    [filteredSelectedOptions, filteredUnselectedOptions]\n  )\n\n  const handleClose = () => {\n    setOpen(false)\n    onClose?.()\n  }\n\n  const renderMenuContent = () => (\n    <>\n      {field.searchable !== false && (\n        <>\n          <Input\n            ref={inputRef}\n            role=\"combobox\"\n            aria-autocomplete=\"list\"\n            aria-expanded={true}\n            aria-haspopup=\"listbox\"\n            aria-controls={`${baseId}-listbox`}\n            aria-activedescendant={\n              highlightedIndex >= 0\n                ? `${baseId}-item-${highlightedIndex}`\n                : undefined\n            }\n            placeholder={context.i18n.placeholders.searchField(\n              field.label || \"\"\n            )}\n            className={cn(\n              \"border-input h-8 rounded-none border-0 bg-transparent! px-2 text-sm shadow-none\",\n              \"focus-visible:border-border focus-visible:ring-0 focus-visible:ring-offset-0\",\n              open && \"placeholder:text-foreground\"\n            )}\n            value={searchInput}\n            onChange={(e) => setSearchInput(e.target.value)}\n            onBlur={() => open && inputRef.current?.focus()}\n            onClick={(e) => e.stopPropagation()}\n            onKeyDown={(e) => {\n              if (e.key === \"ArrowDown\") {\n                e.preventDefault()\n                if (allFilteredOptions.length > 0) {\n                  setHighlightedIndex((prev) =>\n                    prev < allFilteredOptions.length - 1 ? prev + 1 : 0\n                  )\n                }\n              } else if (e.key === \"ArrowUp\") {\n                e.preventDefault()\n                if (allFilteredOptions.length > 0) {\n                  setHighlightedIndex((prev) =>\n                    prev > 0 ? prev - 1 : allFilteredOptions.length - 1\n                  )\n                }\n              } else if (e.key === \"ArrowLeft\") {\n                e.preventDefault()\n                setOpen(false)\n              } else if (e.key === \"Enter\" && highlightedIndex >= 0) {\n                e.preventDefault()\n                const option = allFilteredOptions[highlightedIndex]\n                if (option) {\n                  const isSelected = effectiveValues.includes(option.value as T)\n                  const next = isSelected\n                    ? (effectiveValues.filter((v) => v !== option.value) as T[])\n                    : isMultiSelect\n                      ? ([...effectiveValues, option.value] as T[])\n                      : ([option.value] as T[])\n\n                  if (\n                    !isSelected &&\n                    isMultiSelect &&\n                    field.maxSelections &&\n                    next.length > field.maxSelections\n                  ) {\n                    return\n                  }\n\n                  if (field.onValueChange) {\n                    field.onValueChange(next)\n                  } else {\n                    onChange(next)\n                  }\n                  if (!isMultiSelect) handleClose()\n                }\n              }\n              e.stopPropagation()\n            }}\n          />\n          <DropdownMenuSeparator />\n        </>\n      )}\n      <div className=\"relative flex max-h-full\">\n        <div\n          className=\"flex max-h-[min(var(--available-height),24rem)] w-full scroll-pt-2 scroll-pb-2 flex-col overscroll-contain\"\n          role=\"listbox\"\n          id={`${baseId}-listbox`}\n        >\n          <ScrollArea className=\"size-full min-h-0 **:data-[slot=scroll-area-scrollbar]:m-0 [&_[data-slot=scroll-area-viewport]]:h-full [&_[data-slot=scroll-area-viewport]]:overscroll-contain\">\n            {allFilteredOptions.length === 0 && (\n              <div className=\"text-muted-foreground py-2 text-center text-sm\">\n                {context.i18n.noResultsFound}\n              </div>\n            )}\n\n            {/* Selected items */}\n            {filteredSelectedOptions.length > 0 && (\n              <DropdownMenuGroup className=\"px-1\">\n                {filteredSelectedOptions.map((option, index) => {\n                  const isHighlighted = highlightedIndex === index\n                  const itemId = `${baseId}-item-${index}`\n\n                  return (\n                    <DropdownMenuCheckboxItem\n                      key={String(option.value)}\n                      id={itemId}\n                      role=\"option\"\n                      aria-selected={isHighlighted}\n                      data-highlighted={isHighlighted || undefined}\n                      onMouseEnter={() => setHighlightedIndex(index)}\n                      checked={true}\n                      className={cn(\n                        \"data-highlighted:bg-accent data-highlighted:text-accent-foreground\",\n                        option.className\n                      )}\n                      onSelect={(e) => {\n                        if (isMultiSelect) e.preventDefault()\n                      }}\n                      onCheckedChange={() => {\n                        const next = effectiveValues.filter(\n                          (v) => v !== option.value\n                        ) as T[]\n                        if (field.onValueChange) {\n                          field.onValueChange(next)\n                        } else {\n                          onChange(next)\n                        }\n                        if (!isMultiSelect) handleClose()\n                      }}\n                    >\n                      {option.icon && option.icon}\n                      <span className=\"truncate\">{option.label}</span>\n                    </DropdownMenuCheckboxItem>\n                  )\n                })}\n              </DropdownMenuGroup>\n            )}\n\n            {/* Separator */}\n            {filteredSelectedOptions.length > 0 &&\n              filteredUnselectedOptions.length > 0 && (\n                <DropdownMenuSeparator className=\"mx-0\" />\n              )}\n\n            {/* Available items */}\n            {filteredUnselectedOptions.length > 0 && (\n              <DropdownMenuGroup className=\"px-1\">\n                {filteredUnselectedOptions.map((option, index) => {\n                  const overallIndex = index + filteredSelectedOptions.length\n                  const isHighlighted = highlightedIndex === overallIndex\n                  const itemId = `${baseId}-item-${overallIndex}`\n\n                  return (\n                    <DropdownMenuCheckboxItem\n                      key={String(option.value)}\n                      id={itemId}\n                      role=\"option\"\n                      aria-selected={isHighlighted}\n                      data-highlighted={isHighlighted || undefined}\n                      onMouseEnter={() => setHighlightedIndex(overallIndex)}\n                      checked={false}\n                      className={cn(\n                        \"data-highlighted:bg-accent data-highlighted:text-accent-foreground\",\n                        option.className\n                      )}\n                      onSelect={(e) => {\n                        if (isMultiSelect) e.preventDefault()\n                      }}\n                      onCheckedChange={() => {\n                        const next = isMultiSelect\n                          ? ([...effectiveValues, option.value] as T[])\n                          : ([option.value] as T[])\n\n                        if (\n                          isMultiSelect &&\n                          field.maxSelections &&\n                          next.length > field.maxSelections\n                        ) {\n                          return\n                        }\n\n                        if (field.onValueChange) {\n                          field.onValueChange(next)\n                        } else {\n                          onChange(next)\n                        }\n                        if (!isMultiSelect) handleClose()\n                      }}\n                    >\n                      {option.icon && option.icon}\n                      <span className=\"truncate\">{option.label}</span>\n                    </DropdownMenuCheckboxItem>\n                  )\n                })}\n              </DropdownMenuGroup>\n            )}\n          </ScrollArea>\n        </div>\n      </div>\n    </>\n  )\n\n  if (inline) {\n    return <div className=\"w-full\">{renderMenuContent()}</div>\n  }\n\n  return (\n    <DropdownMenu\n      open={open}\n      onOpenChange={(open) => {\n        setOpen(open)\n        if (!open) {\n          setTimeout(() => setSearchInput(\"\"), 200)\n        }\n      }}\n    >\n      <DropdownMenuTrigger\n        render={\n          <Button variant=\"outline\" size={context.size}>\n            <div className=\"flex items-center gap-1.5\">\n              {field.customValueRenderer ? (\n                field.customValueRenderer(values, field.options || [])\n              ) : (\n                <>\n                  {selectedOptions.length > 0 && (\n                    <div className=\"flex items-center -space-x-1.5\">\n                      {selectedOptions.slice(0, 3).map((option) => (\n                        <div key={String(option.value)}>{option.icon}</div>\n                      ))}\n                    </div>\n                  )}\n                  {selectedOptions.length === 1\n                    ? selectedOptions[0].label\n                    : selectedOptions.length > 1\n                      ? `${selectedOptions.length} ${context.i18n.selectedCount}`\n                      : context.i18n.select}\n                </>\n              )}\n            </div>\n          </Button>\n        }\n      />\n      <DropdownMenuContent\n        align=\"start\"\n        className={cn(\"w-[200px] px-0\", field.className)}\n      >\n        {renderMenuContent()}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  )\n}\n\nfunction FilterValueSelector<T = unknown>({\n  field,\n  values,\n  onChange,\n  operator,\n  autoFocus,\n}: FilterValueSelectorProps<T>) {\n  const context = useFilterContext()\n\n  if (operator === \"empty\" || operator === \"not_empty\") {\n    return null\n  }\n\n  if (field.customRenderer) {\n    return (\n      <ButtonGroupText className=\"hover:bg-accent aria-expanded:bg-accent bg-background dark:bg-input/30 text-start whitespace-nowrap outline-hidden\">\n        {field.customRenderer({ field, values, onChange, operator })}\n      </ButtonGroupText>\n    )\n  }\n\n  if (field.type === \"text\") {\n    return (\n      <FilterInput\n        type=\"text\"\n        value={(values[0] as string) || \"\"}\n        onChange={(e) => onChange([e.target.value] as T[])}\n        placeholder={field.placeholder}\n        pattern={field.pattern}\n        field={field}\n        className={cn(\"w-36\", field.className)}\n        autoFocus={autoFocus}\n      />\n    )\n  }\n\n  if (field.type === \"select\" || field.type === \"multiselect\") {\n    return (\n      <SelectOptionsPopover field={field} values={values} onChange={onChange} />\n    )\n  }\n\n  return (\n    <SelectOptionsPopover field={field} values={values} onChange={onChange} />\n  )\n}\nexport interface Filter<T = unknown> {\n  id: string\n  field: string\n  operator: string\n  values: T[]\n}\n\nexport interface FilterGroup<T = unknown> {\n  id: string\n  label?: string\n  filters: Filter<T>[]\n  fields: FilterFieldConfig<T>[]\n}\n\ninterface FiltersContentProps<T = unknown> {\n  filters: Filter<T>[]\n  fields: FilterFieldsConfig<T>\n  onChange: (filters: Filter<T>[]) => void\n}\n\nexport const FiltersContent = <T = unknown,>({\n  filters,\n  fields,\n  onChange,\n}: FiltersContentProps<T>) => {\n  const context = useFilterContext()\n  const fieldsMap = useMemo(() => getFieldsMap(fields), [fields])\n\n  const updateFilter = useCallback(\n    (filterId: string, updates: Partial<Filter<T>>) => {\n      onChange(\n        filters.map((filter) => {\n          if (filter.id === filterId) {\n            const updatedFilter = { ...filter, ...updates }\n            if (\n              updates.operator === \"empty\" ||\n              updates.operator === \"not_empty\"\n            ) {\n              updatedFilter.values = [] as T[]\n            }\n            return updatedFilter\n          }\n          return filter\n        })\n      )\n    },\n    [filters, onChange]\n  )\n\n  const removeFilter = useCallback(\n    (filterId: string) => {\n      onChange(filters.filter((filter) => filter.id !== filterId))\n    },\n    [filters, onChange]\n  )\n\n  return (\n    <div\n      className={cn(\n        filtersContainerVariants({\n          variant: context.variant,\n          size: context.size,\n        }),\n        context.className\n      )}\n    >\n      {filters.map((filter) => {\n        const field = fieldsMap[filter.field]\n        if (!field) return null\n\n        return (\n          <ButtonGroup key={filter.id}>\n            <ButtonGroupText>\n              {field.icon && field.icon}\n              {field.label}\n            </ButtonGroupText>\n\n            <FilterOperatorDropdown<T>\n              field={field}\n              operator={filter.operator}\n              values={filter.values}\n              onChange={(operator) => updateFilter(filter.id, { operator })}\n            />\n\n            <FilterValueSelector<T>\n              field={field}\n              values={filter.values}\n              onChange={(values) => updateFilter(filter.id, { values })}\n              operator={filter.operator}\n              autoFocus={false}\n            />\n\n            <FilterRemoveButton onClick={() => removeFilter(filter.id)} />\n          </ButtonGroup>\n        )\n      })}\n    </div>\n  )\n}\n\ninterface FiltersProps<T = unknown> {\n  filters: Filter<T>[]\n  fields: FilterFieldsConfig<T>\n  onChange: (filters: Filter<T>[]) => void\n  className?: string\n  variant?: \"solid\" | \"default\"\n  size?: \"sm\" | \"default\" | \"lg\"\n  radius?: \"default\" | \"full\"\n  i18n?: Partial<FilterI18nConfig>\n  showSearchInput?: boolean\n  trigger?: React.ReactNode\n  allowMultiple?: boolean\n  menuPopupClassName?: string\n  collapseAddButton?: boolean\n  enableShortcut?: boolean\n  shortcutKey?: string\n  shortcutLabel?: string\n}\n\ninterface FilterSubmenuContentProps<T = unknown> {\n  field: FilterFieldConfig<T>\n  currentValues: T[]\n  isMultiSelect: boolean\n  onToggle: (value: T, isSelected: boolean) => void\n  i18n: FilterI18nConfig\n  isActive?: boolean\n  onActive?: () => void\n  onBack?: () => void\n  onClose?: () => void\n}\n\nfunction FilterSubmenuContent<T = unknown>({\n  field,\n  currentValues,\n  isMultiSelect,\n  onToggle,\n  i18n,\n  isActive,\n  onActive,\n  onBack,\n  onClose,\n}: FilterSubmenuContentProps<T>) {\n  const [searchInput, setSearchInput] = useState(\"\")\n  const [highlightedIndex, setHighlightedIndex] = useState(-1)\n  const inputRef = useRef<HTMLInputElement>(null)\n  const baseId = useId()\n\n  useEffect(() => {\n    if (isActive) {\n      if (field.searchable !== false) {\n        inputRef.current?.focus()\n      } else {\n        const listbox = document.getElementById(`${baseId}-listbox`)\n        listbox?.focus()\n      }\n    }\n  }, [isActive, field.searchable, baseId])\n\n  useEffect(() => {\n    setHighlightedIndex(-1)\n  }, [searchInput])\n\n  useEffect(() => {\n    if (highlightedIndex >= 0 && isActive) {\n      const element = document.getElementById(\n        `${baseId}-item-${highlightedIndex}`\n      )\n      element?.scrollIntoView({ block: \"nearest\" })\n    }\n  }, [highlightedIndex, isActive, baseId])\n\n  const filteredOptions = useMemo(() => {\n    return (\n      field.options?.filter((option) => {\n        const isSelected = currentValues.includes(option.value)\n        if (isSelected) return true\n        if (!searchInput) return true\n        return option.label.toLowerCase().includes(searchInput.toLowerCase())\n      }) || []\n    )\n  }, [field.options, searchInput, currentValues])\n\n  useEffect(() => {\n    if (isActive && filteredOptions.length > 0) {\n      setHighlightedIndex(0)\n    }\n  }, [isActive, filteredOptions.length])\n\n  return (\n    <div className=\"flex flex-col\" onMouseEnter={onActive}>\n      {field.searchable !== false && (\n        <>\n          <Input\n            ref={inputRef}\n            role=\"combobox\"\n            aria-autocomplete=\"list\"\n            aria-expanded={true}\n            aria-haspopup=\"listbox\"\n            aria-controls={`${baseId}-listbox`}\n            aria-activedescendant={\n              highlightedIndex >= 0\n                ? `${baseId}-item-${highlightedIndex}`\n                : undefined\n            }\n            placeholder={i18n.placeholders.searchField(field.label || \"\")}\n            className={cn(\n              \"h-8 rounded-none border-0 bg-transparent! px-2 text-sm shadow-none\",\n              \"focus-visible:border-border focus-visible:ring-0 focus-visible:ring-offset-0\",\n              isActive && \"placeholder:text-foreground\"\n            )}\n            value={searchInput}\n            onBlur={() => isActive && inputRef.current?.focus()}\n            onChange={(e) => setSearchInput(e.target.value)}\n            onFocus={() => onActive?.()}\n            onMouseEnter={(e) => {\n              onActive?.()\n              e.stopPropagation()\n            }}\n            onClick={(e) => e.stopPropagation()}\n            onKeyDown={(e) => {\n              if (e.key === \"ArrowDown\") {\n                e.preventDefault()\n                if (filteredOptions.length > 0) {\n                  setHighlightedIndex((prev) =>\n                    prev < filteredOptions.length - 1 ? prev + 1 : 0\n                  )\n                }\n              } else if (e.key === \"ArrowUp\") {\n                e.preventDefault()\n                if (filteredOptions.length > 0) {\n                  setHighlightedIndex((prev) =>\n                    prev > 0 ? prev - 1 : filteredOptions.length - 1\n                  )\n                }\n              } else if (e.key === \"ArrowLeft\") {\n                e.preventDefault()\n                onBack?.()\n              } else if (e.key === \"Enter\" && highlightedIndex >= 0) {\n                e.preventDefault()\n                const option = filteredOptions[highlightedIndex]\n                if (option) {\n                  onToggle(\n                    option.value as T,\n                    currentValues.includes(option.value)\n                  )\n                  if (!isMultiSelect) {\n                    onBack?.()\n                  }\n                }\n              } else if (e.key === \"Escape\") {\n                e.preventDefault()\n                onClose?.()\n              }\n              e.stopPropagation()\n            }}\n          />\n          <DropdownMenuSeparator />\n        </>\n      )}\n      <div className=\"relative flex max-h-full\">\n        <div\n          className=\"flex max-h-[min(var(--available-height),24rem)] w-full scroll-pt-2 scroll-pb-2 flex-col overscroll-contain outline-hidden\"\n          role=\"listbox\"\n          id={`${baseId}-listbox`}\n          tabIndex={field.searchable === false ? 0 : -1}\n          onKeyDown={(e) => {\n            if (field.searchable === false) {\n              if (e.key === \"ArrowDown\") {\n                e.preventDefault()\n                if (filteredOptions.length > 0) {\n                  setHighlightedIndex((prev) =>\n                    prev < filteredOptions.length - 1 ? prev + 1 : 0\n                  )\n                }\n              } else if (e.key === \"ArrowUp\") {\n                e.preventDefault()\n                if (filteredOptions.length > 0) {\n                  setHighlightedIndex((prev) =>\n                    prev > 0 ? prev - 1 : filteredOptions.length - 1\n                  )\n                }\n              } else if (e.key === \"ArrowLeft\") {\n                e.preventDefault()\n                onBack?.()\n              } else if (e.key === \"Enter\" && highlightedIndex >= 0) {\n                e.preventDefault()\n                const option = filteredOptions[highlightedIndex]\n                if (option) {\n                  onToggle(\n                    option.value as T,\n                    currentValues.includes(option.value)\n                  )\n                  if (!isMultiSelect) {\n                    onBack?.()\n                  }\n                }\n              } else if (e.key === \"Escape\") {\n                e.preventDefault()\n                onClose?.()\n              }\n              e.stopPropagation()\n            }\n          }}\n        >\n          <ScrollArea className=\"size-full min-h-0 **:data-[slot=scroll-area-scrollbar]:m-0 [&_[data-slot=scroll-area-viewport]]:h-full [&_[data-slot=scroll-area-viewport]]:overscroll-contain\">\n            {filteredOptions.length === 0 ? (\n              <div className=\"text-muted-foreground py-2 text-center text-sm\">\n                {i18n.noResultsFound}\n              </div>\n            ) : (\n              <DropdownMenuGroup>\n                {filteredOptions.map((option, index) => {\n                  const isSelected = currentValues.includes(option.value)\n                  const isHighlighted = highlightedIndex === index\n                  const itemId = `${baseId}-item-${index}`\n\n                  return (\n                    <DropdownMenuCheckboxItem\n                      key={String(option.value)}\n                      id={itemId}\n                      role=\"option\"\n                      aria-selected={isHighlighted}\n                      data-highlighted={isHighlighted || undefined}\n                      onMouseEnter={() => setHighlightedIndex(index)}\n                      checked={isSelected}\n                      className={cn(\n                        \"data-highlighted:bg-accent data-highlighted:text-accent-foreground\",\n                        option.className\n                      )}\n                      onSelect={(e) => {\n                        if (isMultiSelect) e.preventDefault()\n                      }}\n                      onCheckedChange={() =>\n                        onToggle(option.value as T, isSelected)\n                      }\n                    >\n                      {option.icon && option.icon}\n                      <span className=\"truncate\">{option.label}</span>\n                    </DropdownMenuCheckboxItem>\n                  )\n                })}\n              </DropdownMenuGroup>\n            )}\n          </ScrollArea>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport function Filters<T = unknown>({\n  filters,\n  fields,\n  onChange,\n  className,\n  variant = \"default\",\n  size = \"default\",\n  radius = \"default\",\n  i18n,\n  showSearchInput = true,\n  trigger,\n  allowMultiple = true,\n  menuPopupClassName,\n  enableShortcut = false,\n  shortcutKey = \"f\",\n  shortcutLabel = \"F\",\n}: FiltersProps<T>) {\n  const [addFilterOpen, setAddFilterOpen] = useState(false)\n  const [menuSearchInput, setMenuSearchInput] = useState(\"\")\n  const [activeMenu, setActiveMenu] = useState<string>(\"root\")\n  const [openSubMenu, setOpenSubMenu] = useState<string | null>(null)\n  const [highlightedIndex, setHighlightedIndex] = useState(-1)\n  const [lastAddedFilterId, setLastAddedFilterId] = useState<string | null>(\n    null\n  )\n  const rootInputRef = useRef<HTMLInputElement>(null)\n  const rootId = useId()\n\n  useEffect(() => {\n    if (!enableShortcut) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (\n        e.key.toLowerCase() === shortcutKey.toLowerCase() &&\n        !addFilterOpen &&\n        !(\n          document.activeElement instanceof HTMLInputElement ||\n          document.activeElement instanceof HTMLTextAreaElement\n        )\n      ) {\n        e.preventDefault()\n        setAddFilterOpen(true)\n      }\n    }\n\n    window.addEventListener(\"keydown\", handleKeyDown)\n    return () => window.removeEventListener(\"keydown\", handleKeyDown)\n  }, [enableShortcut, shortcutKey, addFilterOpen])\n\n  useEffect(() => {\n    if (addFilterOpen && activeMenu === \"root\") {\n      rootInputRef.current?.focus()\n    }\n  }, [addFilterOpen, activeMenu])\n\n  useEffect(() => {\n    setHighlightedIndex(-1)\n  }, [menuSearchInput])\n\n  useEffect(() => {\n    if (highlightedIndex >= 0 && addFilterOpen) {\n      const element = document.getElementById(\n        `${rootId}-item-${highlightedIndex}`\n      )\n      element?.scrollIntoView({ block: \"nearest\" })\n    }\n  }, [highlightedIndex, addFilterOpen, rootId])\n\n  useEffect(() => {\n    if (!addFilterOpen) {\n      setOpenSubMenu(null)\n    }\n  }, [addFilterOpen])\n\n  // Track which filter instance is being built in the current Add Filter menu session\n  // Maps fieldKey -> unique filterId created during this open session\n  const [sessionFilterIds, setSessionFilterIds] = useState<\n    Record<string, string>\n  >({})\n\n  useEffect(() => {\n    if (lastAddedFilterId) {\n      const timer = setTimeout(() => {\n        setLastAddedFilterId(null)\n      }, 1000)\n      return () => clearTimeout(timer)\n    }\n  }, [lastAddedFilterId])\n\n  const mergedI18n: FilterI18nConfig = {\n    ...DEFAULT_I18N,\n    ...i18n,\n    operators: { ...DEFAULT_I18N.operators, ...i18n?.operators },\n    placeholders: { ...DEFAULT_I18N.placeholders, ...i18n?.placeholders },\n    validation: { ...DEFAULT_I18N.validation, ...i18n?.validation },\n  }\n\n  const fieldsMap = useMemo(() => getFieldsMap(fields), [fields])\n\n  const updateFilter = useCallback(\n    (filterId: string, updates: Partial<Filter<T>>) => {\n      onChange(\n        filters.map((filter) => {\n          if (filter.id === filterId) {\n            const updatedFilter = { ...filter, ...updates }\n            if (\n              updates.operator === \"empty\" ||\n              updates.operator === \"not_empty\"\n            ) {\n              updatedFilter.values = [] as T[]\n            }\n            return updatedFilter\n          }\n          return filter\n        })\n      )\n    },\n    [filters, onChange]\n  )\n\n  const removeFilter = useCallback(\n    (filterId: string) => {\n      onChange(filters.filter((filter) => filter.id !== filterId))\n    },\n    [filters, onChange]\n  )\n\n  const addFilter = useCallback(\n    (fieldKey: string) => {\n      const field = fieldsMap[fieldKey]\n      if (field && field.key) {\n        const defaultOperator =\n          field.defaultOperator ||\n          (field.type === \"multiselect\" ? \"is_any_of\" : \"is\")\n        const defaultValues: unknown[] = field.type === \"text\" ? [\"\"] : []\n        const newFilter = createFilter<T>(\n          fieldKey,\n          defaultOperator,\n          defaultValues as T[]\n        )\n        setLastAddedFilterId(newFilter.id)\n        onChange([...filters, newFilter])\n        setAddFilterOpen(false)\n        setMenuSearchInput(\"\")\n      }\n    },\n    [fieldsMap, filters, onChange]\n  )\n\n  useEffect(() => {\n    if (addFilterOpen && activeMenu === \"root\") {\n      rootInputRef.current?.focus()\n    }\n  }, [addFilterOpen, activeMenu])\n\n  const selectableFields = useMemo(() => {\n    const flatFields = flattenFields(fields)\n    return flatFields.filter((field) => {\n      if (!field.key || field.type === \"separator\") return false\n      if (allowMultiple) return true\n      return !filters.some((filter) => filter.field === field.key)\n    })\n  }, [fields, filters, allowMultiple])\n\n  const filteredFields = useMemo(() => {\n    return selectableFields.filter(\n      (f) =>\n        !menuSearchInput ||\n        f.label?.toLowerCase().includes(menuSearchInput.toLowerCase())\n    )\n  }, [selectableFields, menuSearchInput])\n\n  useEffect(() => {\n    if (addFilterOpen && filteredFields.length > 0) {\n      setHighlightedIndex(0)\n    }\n  }, [addFilterOpen, filteredFields.length])\n\n  const triggerButton = useRender({\n    render: trigger as React.ReactElement,\n    defaultTagName: \"button\",\n  })\n\n  return (\n    <FilterContext.Provider\n      value={{\n        variant,\n        size,\n        radius,\n        i18n: mergedI18n,\n        className,\n        trigger,\n        allowMultiple,\n      }}\n    >\n      <div\n        className={cn(filtersContainerVariants({ variant, size }), className)}\n      >\n        {selectableFields.length > 0 && (\n          <DropdownMenu\n            open={addFilterOpen}\n            onOpenChange={(open) => {\n              setAddFilterOpen(open)\n              if (!open) {\n                setMenuSearchInput(\"\")\n                setSessionFilterIds({})\n              } else {\n                setActiveMenu(\"root\")\n              }\n            }}\n          >\n            <DropdownMenuTrigger render={triggerButton} />\n            <DropdownMenuContent\n              className={cn(\"w-[220px]\", menuPopupClassName)}\n              align=\"start\"\n            >\n              {showSearchInput && (\n                <>\n                  <div className=\"relative\">\n                    <Input\n                      ref={rootInputRef}\n                      role=\"combobox\"\n                      aria-controls={`${rootId}-listbox`}\n                      aria-activedescendant={\n                        highlightedIndex >= 0\n                          ? `${rootId}-item-${highlightedIndex}`\n                          : undefined\n                      }\n                      placeholder={mergedI18n.searchFields}\n                      className={cn(\n                        \"h-8 rounded-none border-0 bg-transparent! px-2 text-sm shadow-none\",\n                        \"focus-visible:border-border focus-visible:ring-0 focus-visible:ring-offset-0\",\n                        activeMenu === \"root\" && \"placeholder:text-foreground\"\n                      )}\n                      value={menuSearchInput}\n                      onFocus={() => setActiveMenu(\"root\")}\n                      onMouseEnter={() => setActiveMenu(\"root\")}\n                      onBlur={() =>\n                        activeMenu === \"root\" && rootInputRef.current?.focus()\n                      }\n                      onChange={(e) => setMenuSearchInput(e.target.value)}\n                      onClick={(e) => e.stopPropagation()}\n                      onKeyDown={(e) => {\n                        if (e.key === \"ArrowDown\") {\n                          e.preventDefault()\n                          if (filteredFields.length > 0) {\n                            setHighlightedIndex((prev) =>\n                              prev < filteredFields.length - 1 ? prev + 1 : 0\n                            )\n                          }\n                        } else if (e.key === \"ArrowUp\") {\n                          e.preventDefault()\n                          if (filteredFields.length > 0) {\n                            setHighlightedIndex((prev) =>\n                              prev > 0 ? prev - 1 : filteredFields.length - 1\n                            )\n                          }\n                        } else if (\n                          (e.key === \"ArrowRight\" || e.key === \"ArrowLeft\") &&\n                          highlightedIndex >= 0\n                        ) {\n                          const field = filteredFields[highlightedIndex]\n                          const hasSubMenu =\n                            field &&\n                            (field.type === \"select\" ||\n                              field.type === \"multiselect\") &&\n                            field.options?.length\n\n                          if (e.key === \"ArrowRight\" && hasSubMenu) {\n                            e.preventDefault()\n                            setOpenSubMenu(field.key || null)\n                            setActiveMenu(field.key || \"root\")\n                          } else if (e.key === \"ArrowLeft\") {\n                            e.preventDefault()\n                            if (openSubMenu) {\n                              setOpenSubMenu(null)\n                              setActiveMenu(\"root\")\n                            }\n                          }\n                        } else if (e.key === \"Enter\" && highlightedIndex >= 0) {\n                          e.preventDefault()\n                          const field = filteredFields[highlightedIndex]\n                          if (field.key) {\n                            const hasSubMenu =\n                              (field.type === \"select\" ||\n                                field.type === \"multiselect\") &&\n                              field.options?.length\n                            if (!hasSubMenu) {\n                              addFilter(field.key)\n                            } else {\n                              if (openSubMenu === field.key) {\n                                setOpenSubMenu(null)\n                                setActiveMenu(\"root\")\n                              } else {\n                                setOpenSubMenu(field.key)\n                                setActiveMenu(field.key)\n                              }\n                            }\n                          }\n                        } else if (e.key === \"Escape\") {\n                          setAddFilterOpen(false)\n                        }\n                        e.stopPropagation()\n                      }}\n                    />\n                    {enableShortcut && shortcutLabel && (\n                      <Kbd className=\"bg-background absolute top-1/2 right-2 -translate-y-1/2 border\">\n                        {shortcutLabel}\n                      </Kbd>\n                    )}\n                  </div>\n                  <DropdownMenuSeparator />\n                </>\n              )}\n\n              <div className=\"relative flex max-h-full\">\n                <div\n                  className=\"flex max-h-[min(var(--available-height),24rem)] w-full scroll-pt-2 scroll-pb-2 flex-col overscroll-contain\"\n                  role=\"listbox\"\n                  id={`${rootId}-listbox`}\n                  onMouseEnter={() => setActiveMenu(\"root\")}\n                >\n                  <ScrollArea className=\"**:data-[slot=scroll-area-scrollbar]:m-0\">\n                    {(() => {\n                      if (filteredFields.length === 0) {\n                        return (\n                          <div className=\"text-muted-foreground py-2 text-center text-sm\">\n                            {mergedI18n.noFieldsFound}\n                          </div>\n                        )\n                      }\n\n                      return filteredFields.map((field, index) => {\n                        const isHighlighted = highlightedIndex === index\n                        const itemId = `${rootId}-item-${index}`\n                        const hasSubMenu =\n                          (field.type === \"select\" ||\n                            field.type === \"multiselect\") &&\n                          field.options?.length\n\n                        if (hasSubMenu) {\n                          const isMultiSelect = field.type === \"multiselect\"\n                          const fieldKey = field.key as string\n                          const sessionFilterId = sessionFilterIds[fieldKey]\n                          const sessionFilter = sessionFilterId\n                            ? filters.find((f) => f.id === sessionFilterId)\n                            : null\n                          const currentValues = sessionFilter?.values || []\n\n                          return (\n                            <DropdownMenuSub\n                              key={fieldKey}\n                              open={openSubMenu === fieldKey}\n                              onOpenChange={(open) => {\n                                if (open) {\n                                  setOpenSubMenu(fieldKey)\n                                } else {\n                                  if (openSubMenu === fieldKey) {\n                                    setOpenSubMenu(null)\n                                    setActiveMenu(\"root\")\n                                  }\n                                }\n                              }}\n                            >\n                              <DropdownMenuSubTrigger\n                                id={itemId}\n                                role=\"option\"\n                                aria-selected={isHighlighted}\n                                data-highlighted={isHighlighted || undefined}\n                                onMouseEnter={() => {\n                                  setHighlightedIndex(index)\n                                  setActiveMenu(\"root\")\n                                }}\n                                className=\"data-popup-open:bg-accent data-popup-open:text-accent-foreground data-highlighted:bg-accent data-highlighted:text-accent-foreground\"\n                              >\n                                {field.icon}\n                                <span>{field.label}</span>\n                              </DropdownMenuSubTrigger>\n                              <DropdownMenuSubContent\n                                className=\"w-[200px]\"\n                                side=\"right\"\n                              >\n                                <FilterSubmenuContent\n                                  field={field}\n                                  currentValues={currentValues}\n                                  isMultiSelect={isMultiSelect}\n                                  i18n={mergedI18n}\n                                  isActive={activeMenu === fieldKey}\n                                  onActive={() => {\n                                    if (field.searchable !== false) {\n                                      setActiveMenu(fieldKey)\n                                    }\n                                  }}\n                                  onBack={() => {\n                                    setOpenSubMenu(null)\n                                    setActiveMenu(\"root\")\n                                  }}\n                                  onClose={() => setAddFilterOpen(false)}\n                                  onToggle={(value, isSelected) => {\n                                    if (isMultiSelect) {\n                                      const nextValues = isSelected\n                                        ? (currentValues.filter(\n                                            (v) => v !== value\n                                          ) as T[])\n                                        : ([...currentValues, value] as T[])\n\n                                      if (sessionFilter) {\n                                        if (nextValues.length === 0) {\n                                          onChange(\n                                            filters.filter(\n                                              (f) => f.id !== sessionFilter.id\n                                            )\n                                          )\n                                          setSessionFilterIds((prev) => ({\n                                            ...prev,\n                                            [fieldKey]: \"\",\n                                          }))\n                                        } else {\n                                          onChange(\n                                            filters.map((f) =>\n                                              f.id === sessionFilter.id\n                                                ? { ...f, values: nextValues }\n                                                : f\n                                            )\n                                          )\n                                        }\n                                      } else {\n                                        const newFilter = createFilter<T>(\n                                          fieldKey,\n                                          field.defaultOperator || \"is_any_of\",\n                                          nextValues\n                                        )\n                                        onChange([...filters, newFilter])\n                                        setSessionFilterIds((prev) => ({\n                                          ...prev,\n                                          [fieldKey]: newFilter.id,\n                                        }))\n                                      }\n                                    } else {\n                                      const newFilter = createFilter<T>(\n                                        fieldKey,\n                                        field.defaultOperator || \"is\",\n                                        [value] as T[]\n                                      )\n                                      setLastAddedFilterId(newFilter.id)\n                                      onChange([...filters, newFilter])\n                                      setAddFilterOpen(false)\n                                    }\n                                  }}\n                                />\n                              </DropdownMenuSubContent>\n                            </DropdownMenuSub>\n                          )\n                        }\n\n                        return (\n                          <DropdownMenuItem\n                            key={field.key}\n                            id={itemId}\n                            role=\"option\"\n                            aria-selected={isHighlighted}\n                            data-highlighted={isHighlighted || undefined}\n                            onMouseEnter={() => setHighlightedIndex(index)}\n                            onClick={() => field.key && addFilter(field.key)}\n                            className=\"data-highlighted:bg-accent data-highlighted:text-accent-foreground\"\n                          >\n                            {field.icon}\n                            <span>{field.label}</span>\n                          </DropdownMenuItem>\n                        )\n                      })\n                    })()}\n                  </ScrollArea>\n                </div>\n              </div>\n            </DropdownMenuContent>\n          </DropdownMenu>\n        )}\n\n        {filters.map((filter) => {\n          const field = fieldsMap[filter.field]\n          if (!field) return null\n          return (\n            <ButtonGroup key={filter.id}>\n              <ButtonGroupText className=\"bg-background dark:bg-input/30\">\n                {field.icon && field.icon}\n                {field.label}\n              </ButtonGroupText>\n              <FilterOperatorDropdown<T>\n                field={field}\n                operator={filter.operator}\n                values={filter.values}\n                onChange={(operator) => updateFilter(filter.id, { operator })}\n              />\n              <FilterValueSelector<T>\n                field={field}\n                values={filter.values}\n                operator={filter.operator}\n                onChange={(values) => updateFilter(filter.id, { values })}\n                autoFocus={filter.id === lastAddedFilterId}\n              />\n              <FilterRemoveButton onClick={() => removeFilter(filter.id)} />\n            </ButtonGroup>\n          )\n        })}\n      </div>\n    </FilterContext.Provider>\n  )\n}\n\nexport const createFilter = <T = unknown,>(\n  field: string,\n  operator?: string,\n  values: T[] = []\n): Filter<T> => ({\n  id: `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,\n  field,\n  operator: operator || \"is\",\n  values,\n})\n\nexport const createFilterGroup = <T = unknown,>(\n  id: string,\n  label: string,\n  fields: FilterFieldConfig<T>[],\n  initialFilters: Filter<T>[] = []\n): FilterGroup<T> => ({\n  id,\n  label,\n  filters: initialFilters,\n  fields,\n})","target":"components/reui/filters.tsx"}]}