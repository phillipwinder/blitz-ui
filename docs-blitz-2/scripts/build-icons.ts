#!/usr/bin/env tsx
import * as fs from "fs"
import * as path from "path"
import { iconLibraries, type IconLibraryName } from "shadcn/icons"

type IconUsage = Record<IconLibraryName, Set<string>>

function findTsxFiles(dir: string) {
  const files: string[] = []
  const entries = fs.readdirSync(dir, { withFileTypes: true })

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      files.push(...findTsxFiles(fullPath))
    } else if (entry.isFile() && entry.name.endsWith(".tsx")) {
      files.push(fullPath)
    }
  }

  return files
}

function scanIconUsage() {
  const iconUsage: IconUsage = Object.keys(iconLibraries).reduce((acc, key) => {
    acc[key as IconLibraryName] = new Set()
    return acc
  }, {} as IconUsage)

  // 1. Scan for IconPlaceholder usage
  // Only scan base folder - radix is a mirror created by migrate-radix.mts
  const scanDirs = [
    path.join(process.cwd(), "registry/bases"),
    path.join(process.cwd(), "registry-reui/bases/base/patterns"),
    path.join(process.cwd(), "registry-reui/bases/base/reui"),
  ]

  const files: string[] = []
  for (const dir of scanDirs) {
    if (fs.existsSync(dir)) {
      files.push(...findTsxFiles(dir))
    }
  }

  const libraryNames = Object.values(iconLibraries)
    .map((lib) => lib.name)
    .join("|")
  const iconPlaceholderRegex = new RegExp(
    `<IconPlaceholder\\s+([^>]*?)(?:${libraryNames})=["']([^"']+)["']([^>]*?)\\/?>`,
    "g"
  )

  for (const file of files) {
    const content = fs.readFileSync(file, "utf-8")

    let match
    while ((match = iconPlaceholderRegex.exec(content)) !== null) {
      const fullMatch = match[0]

      for (const [libraryName, config] of Object.entries(iconLibraries)) {
        const attrMatch = fullMatch.match(
          new RegExp(`${config.name}=["']([^"']+)["']`)
        )
        if (attrMatch) {
          iconUsage[libraryName as IconLibraryName].add(attrMatch[1])
        }
      }
    }
  }

  // 2. Add unmapped icons from scan-icons output
  const unmappedFile = path.join(
    process.cwd(),
    "registry/icons/unmapped-icons.json"
  )
  if (fs.existsSync(unmappedFile)) {
    try {
      const unmapped = JSON.parse(fs.readFileSync(unmappedFile, "utf-8"))
      if (Array.isArray(unmapped)) {
        unmapped.forEach((item: any) => {
          if (item.icon) {
            // Unmapped icons currently only support Lucide in scan-icons.ts
            iconUsage["lucide"].add(item.icon)
          }
        })
      }
    } catch (e) {
      console.error("Error reading unmapped-icons.json:", e)
    }
  }

  return iconUsage
}

async function generateIconFiles(iconUsage: IconUsage) {
  const outputDir = path.join(process.cwd(), "registry/icons")

  console.log("✓ Generating icon files:")

  for (const [libraryName, config] of Object.entries(iconLibraries)) {
    let icons = Array.from(iconUsage[libraryName as IconLibraryName]).sort()

    if (icons.length === 0) {
      continue
    }

    // Validate that icons exist in the library
    try {
      const mod = await import(config.export)
      const validIcons = new Set<string>()
      const skippedIcons: string[] = []

      // For Lucide, we might want to automatically check for variations
      if (libraryName === "lucide") {
        const tempIcons = new Set(icons)
        icons.forEach((icon) => {
          if (icon.endsWith("Icon")) {
            tempIcons.add(icon.replace(/Icon$/, ""))
          } else {
            tempIcons.add(icon + "Icon")
          }
        })
        icons = Array.from(tempIcons).sort()
      }

      icons.forEach((icon) => {
        if (icon in mod) {
          validIcons.add(icon)
        } else {
          skippedIcons.push(icon)
        }
      })

      if (skippedIcons.length > 0) {
        console.warn(
          `  - ${config.title}: Skipped ${skippedIcons.length} non-existent icons: ${skippedIcons.join(", ")}`
        )
      }

      if (validIcons.size === 0) {
        continue
      }

      const finalIcons = Array.from(validIcons).sort()
      const content = `// Auto-generated by scripts/build-icons.ts
${finalIcons.map((icon) => `export { ${icon} } from "${config.export}"`).join("\n")}
`

      const filename = `__${libraryName}__.ts`
      fs.writeFileSync(path.join(outputDir, filename), content)

      console.log(`  - ${config.title}: ${finalIcons.length} icons`)
    } catch (e) {
      console.error(
        `  - ${config.title}: Failed to load library "${config.export}"`
      )
    }
  }
}

async function main() {
  const iconUsage = scanIconUsage()
  await generateIconFiles(iconUsage)
}

const isWatchMode = process.argv.includes("--watch")

if (isWatchMode) {
  // Only watch base folder - radix is a mirror created by migrate-radix.mts
  const SCAN_DIRS = [
    path.join(process.cwd(), "registry/bases"),
    path.join(process.cwd(), "registry-reui/bases/base/patterns"),
    path.join(process.cwd(), "registry-reui/bases/base/reui"),
  ].filter((dir) => fs.existsSync(dir))

  async function startWatcher() {
    const { default: chokidar } = await import("chokidar")

    await main()

    const watcher = chokidar.watch(SCAN_DIRS, {
      ignored: /(^|[/\\])\../,
      persistent: true,
      ignoreInitial: true,
    })

    const rebuild = async (filename: string) => {
      if (!filename.endsWith(".tsx")) return

      try {
        await main()
      } catch (error) {
        console.error("❌ Icons build failed:", error)
      }
    }

    watcher.on("error", (error) => {
      console.error("❌ Watcher error:", error)
    })

    watcher.on("change", rebuild)
    watcher.on("add", rebuild)

    process.on("SIGINT", async () => {
      await watcher.close()
      process.exit(0)
    })
  }

  startWatcher()
} else {
  main().catch(console.error)
}
